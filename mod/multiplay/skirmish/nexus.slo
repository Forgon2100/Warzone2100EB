/////////////////////////////////////////////////////////////////////
// general ai for skirmish game
/////////////////////////////////////////////////////////////////////
// Warzone2100, Pumpkin Studios,
// alex lee.98/99.
//
/////////////////////////////////////////////////////////////////////

//Tile in world units
#define	TILE					128
#define	NONE					(-1)

// These are final rules of the lexical parser
#define	R_REQUEST_HELP			"help me"
#define	R_REQUEST_BEACON		"drop a beacon"
#define	R_REPORT_SAFETY			"i'm ok"
#define R_REQUEST_ALLY			"ally me"

// These are our own messages - lexical parser should be able to handle them
#define M_REQUEST_HELP			"help me!!"
#define M_REQUEST_BEACON		"drop a beacon"
#define M_AFFIRMATIVE_OK		"ok"
#define M_AFFIRMATIVE_ROGER		"roger"
#define M_ANNOYED				"bug off"
#define M_HELPERS_KILLED		"that was all I had.."
#define M_HELP_NO_UNITS			"I don't have anything"

#define	MAX_PROBABILITY			100

// Base threat range in world units
#define	W_BASE_THREAT_RANGE		((17 + (mapWidth + mapHeight) / 2 / 35) * TILE)
#define ALL_ALLIES				-1

#define	BASE_DEFEND_DURATION	60

// Delay before we repeat our request, in seconds
#define HELP_REQUEST_INTERVAL	50

//in secs
#define BEACON_TIMEOUT			40

#define	MAX_DROIDS				150

//range for trucks to look for more oil
#define MORE_OIL_RANGE			(10 * TILE)
//don't try to build on oil if there's threat within this range
#define	OIL_THREAT_RANGE		(9 * TILE)

#define	MAX_TRUCKS				14
#define	MIN_TRUCKS				3

//Target type values
#define	NO_TARGET_VALUE			0
#define	DROID_TARGET_VALUE		1
#define	OTHER_TARGET_VALUE		2
#define	DEFENSE_TARGET_VALUE	3
#define	RESEARCH_TARGET_VALUE	4
#define	HQ_TARGET_VALUE			5
#define	OIL_TARGET_VALUE		6
#define	FACTORY_TARGET_VALUE	7

#define	UNLIMITED 				(-1)

#define	AA_THREAT_RANGE			1

#define	MAX_DEFENDERS_RADIUS	(TILE * 50)

#define	MAX_VTOL_DEFEND_RADIUS	(TILE * 250)

#define	MIN_BUILDPOWER_CYBFACTORY		25
#define MIN_BUILDPOWER_FACTORY			400
#define MIN_BUILDPOWER_RESCENTER		250
#define MIN_BUILDPOWER_VTOLFACTORY		200

#define MIN_PRODUCTIONPOWER_FACTORY			25
#define MIN_PRODUCTIONPOWER_CYBFACTORY		10
#define MIN_PRODUCTIONPOWER_VTOLFACTORY		100
#define MIN_PRODUCTIONPOWER_TRUCK			50	

#define MIN_BUILDPOWER_DEFENSE				200
#define MIN_BUILDPOWER_EXTRASTRUCTS			200
#define MIN_BUILDPOWER_ARTILLERY			0


// AI will remember max this number of structures
#define	MAX_REBUILD_STRUCT		100

//Total number of technology branches
#define	TECHS					8

//How many best templates to choose from when deciding what template to build
#define	MAX_RANDOM_TEMPLATES	4



private	int				me;			// player for this instance.
public	int				tileExpand;			// rate of exploration

public	int				numDefenders[TECHS],maxDefenders[TECHS];
public	int				numAttackers[TECHS],maxAttackers[TECHS];
public	int				numCyborgs[TECHS],maxCyborgs[TECHS];
public	int				branchRocket,branchFlamer,branchCannon,branchMG,branchArtillery,branchCannonMGMortar,branchRocketMGMortar,branchFlameVtolLaser,techCount[TECHS],maxVtolFacs[TECHS],maxIdleRes[TECHS],
						maxVTOLs[TECHS],numVtolTargets,vtolTargetWeight[10],numRebuildStat[TECHS];
public	RESEARCHSTAT	tech[TECHS][72];		//technology for different research branches
public	STRUCTURESTAT	rebuildStat[TECHS][2];


// structures
private int				baseX,baseY,minx,miny,maxx,maxy,ebaseX,ebaseY;
public float			mapSize;
public	int				numStructs,numIncendrys,numDefStructs,numExtraStructs[TECHS],numWallWeaps,numBaseStruct,numLightCyborgs,numFundamental;
private	STRUCTURESTAT	structChoice[5];
public	STRUCTURESTAT	incendrys[10],structs[16],defStructs[35],extraStructs[TECHS][6],wallWeaps[11];
public	STRUCTURESTAT	sensorTower,wall,cornerWall,resLab,powGen,playerHQ,lassat,factory,derrick,gderrick,cybFactory,archAngel,rippleRocket,
						vtolDefStruct[9],vtolPad,vtolFactory,uplink,baseStruct[8];
public	STRUCTURESTAT	powModule,facModule,resModule,vtolModule,gTower;
public	int				extraStruct;

// unit templates
public	int				numTemplates[TECHS];
public	TEMPLATE		tmpl[TECHS][105];
private	TEMPLATE		tmplChoice[105];

public	TEMPLATE		cybTempl[9],superCyb[21],cybMechanic,cybEngineer,hovertruck;

public	TEMPLATE		vtols[38],vtolAAdroid;
public	int				numVtolTemplates;

public	TEMPLATE		sense[8];
public	int				numSenseTemplates;

public	TEMPLATE		constructor,repair[6],transporterTemp;
public	int				numRepairUnits;
public	int				numSensorUnits;
public	int				numRepairTemplates;


private int				closestAlly;
private int				closestAllyHQx;
private int				closestAllyHQy;
private int				closestAllyDist;
private int				numAllyUnits;
private  int			numAlly;
private int				numDerricks;
public  int				AllyBaseY[10];
public  int				AllyBaseX[10];

private int				closestEnemy;
private int				closestEnemyHQx;
private int				closestEnemyHQy;
private int				closestEnemyDist;

private int				numFactories;
private int				numResearchLab;
private int				numVtolFactory;
private int				numCybFactory;
private int				numFactory;
private int				numPowerGen;

//defend
private GROUP			defendGroup;
private bool			defendbusy;
private BASEOBJ			defendObj;

public  RESEARCHSTAT		nexusDefence,dragon,guardTower,retribution,transporter,cybRepair,hover;
private  RESEARCHSTAT		research;
public  WEAPON			empBomb;

//build
private GROUP			buildGroup;
private int				buildX,buildY,buildX2,buildY2;
public	FEATURESTAT		oilRes;

// attack
private GROUP			attackGroup;
private GROUP			repairGroup;
private BASEOBJ			attackObj,allOutAttack,vtolGrAttackObj[10];

// vtols
private GROUP			vtolDefendGr,vtolAttackGr;

// transport
//private GROUP 			transportGroup;

// generic
private STRUCTURE		structure,structure2,rebuildObj[100];
private DROID			droid;
private FEATURE			feature;
private BASEOBJ			baseobj,baseobj2;
private int				count,count2,result,result2,tempx,tempy;
private bool			boolResult,boolResult2;

private bool			powerSave,_DEBUG,bRunning;
// Hopefully this will be at least as large as MAX_PLAYERS... Why can't I just use MAX_PLAYERS as the array size?!
// P.S. And why can't I put a comment on the same line as a #define??!! Gah, who cares if the lua2 branch works, lets switch to it, anyway.
#define MAX_PLAYERS_HACK 17
private	int				allianceTime[MAX_PLAYERS_HACK];
private int				sender,x,y,beaconX[20],beaconY[20],tBeacon[20],
						tLastHelpRequest,lastHelpPlayer,tHelp,tHelpTimeout,helpX,helpY;
private string			message;

private	int				defendX,defendY,__defendRadiusUnused,tDefendStart,tDefendTimeout,
						defendMoveType,baseRange,curTech,numAttackVtols,
						numDefendVtols,rebuildStructX[MAX_REBUILD_STRUCT],rebuildStructY[MAX_REBUILD_STRUCT],countRebuildStruct;
private	STRUCTURESTAT	rebuildStructStat[MAX_REBUILD_STRUCT];

private STRUCTURESTAT		fundamentalBeingBuilt;
private int			order;	// callback global

/////////////////////////////////////////////////////////////////////
// TRIGGERS

#region triggers

// GAME START AND TIME DEFINITIONS
trigger startLevelTr				(CALL_START_NEXT_LEVEL);
trigger everySec					(every, 10); // for example, a value of 130 = 13 seconds
trigger chainloadTr				(wait, 1);
trigger slowloadTr				(wait, 13);
trigger delayedloadTr				(wait, 35);
//trigger announcementTr				(wait, 100);

// BASE BUILD TRIGGERS
trigger basedetailsTr				(every, 300	);
trigger upgradeStructuresTr			(every, 40);
trigger buildPowerGeneratorsTr		(every, 50	);
trigger buildReCentersTr			(every, 70	);
trigger buildDerrickTr				(every, 140	);
trigger buildFactoryTr				(every, 120	);
trigger buildCyFactoryTr			(every, 150	);
trigger buildVTOLFactoryTr			(every, 350	);
trigger buildBaseTr					(every, 1800);
trigger finishStructsTr				(every, 30);

// FACTORY PRODUCTION
trigger conDroidsTr					(every, 300);	// was 1400
trigger repairDroidsTr				(every, 400);
trigger sensorDroidsTr				(every, 700);
trigger factoryEventTr				(every, 180	);
trigger cyborgFactoryEventTr		(every, 120	);

// DROID AND GROUP ORDER TRIGGER
trigger droidOrdersTr				(every, 100	);
trigger repairGrpTr					(every, 50	);
trigger manageDefendLocationTr		(every, 70);
trigger attackStuffTr				(every, 100	);
trigger remainingEnemyTr			(every, 1400);

// MISC THINGS TO CHECK FOR TRIGGERS
trigger repairBaseTr				(every, 200	);
trigger checkOnAllyTr				(every, 200	);
trigger enemyNearBaseTr				(every, 100);
trigger checkResearchTr				(every, 100);
trigger useLassatTr					(every, 1000);

// BUILD DEFENSE TRIGGERS
trigger fortifyTr					(every,	200);
trigger incendryTr					(every, 60 );
trigger buildOilDefenseOrRetreatTr	(every, 400	);
trigger	rebuildStructureTr			(every, 50);
trigger spendPowerTr				(every, 150);

// EVENT DRIVEN TRIGGERS
trigger reachedTr				(CALL_DROID_REACH_LOCATION, me, ref droid, ref order);
trigger droidBuiltTr				(CALL_NEWDROID,me, ref droid,ref structure);
trigger	structBuiltTr				(CALL_STRUCTBUILT, me, ref droid, ref structure);
trigger droidDestroyedTr			(CALL_DROID_DESTROYED,  me, ref droid);
trigger	structureDestroyedTr		(CALL_STRUCT_DESTROYED, me, ref structure);
trigger newObjectReportTr			(CALL_OBJ_SEEN, me, ref baseobj, ref baseobj2);
trigger defendWatchTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
trigger doResearchTr				(CALL_RESEARCHCOMPLETED, ref research, ref structure, me);
trigger vtolDefendTr				(CALL_STRUCT_ATTACKED, me, ref structure, ref baseobj);
trigger reassignTr					(CALL_PLAYERLEFT,ref count);
trigger takeoverTr					(CALL_UNITTAKEOVER, ref droid);

// VTOL TRIGGERS
trigger vtolStructsTr				(every, 185);
trigger buildVtolsTr				(every, 180);
trigger vtolAttackTr				(every, 200);
trigger vtolEnablerTr				(every, 150);

// MANAGE ALLIANCES
trigger formAllianceEventTr			(every,170);
trigger breakAllianceEventTr		(every,3000);
trigger humanAllianceTr				(CALL_ALLIANCEOFFER,ref count, ref count2);
trigger multiMsgTr					(CALL_AI_MSG, me, ref sender, ref message);
trigger	beaconTr					(CALL_BEACON, me, ref sender, ref x, ref y, ref message);
trigger consoleTr					(CALL_CONSOLE, ref sender, ref message);
trigger watchBaseThreatTr			(every, 120);
trigger manageAllyHelpTr			(every, 80);

/* Events */
event	conDroids;
event	multiMsgEv;
event	beaconEv;
event	watchBaseThreat;
event	manageAllyHelp;
event	everySecEv;
event	manageDefendLocationEv;
event	structureDestroyed;
event	rebuildStructureEv;
event	doResearch;
event	buildDerrick;
event	findEnemy;
//event	announceResearch;
event	factoryEvent;
event   basedetails;
event   droidOrders;
event   checkOnAlly;
event 	repairBase;
event 	repairDroids;
event 	newfortify;
event 	incendry;
event	enemyNearBase;
event	buildReCenters;
event	buildCyFactory;
event	remainingEnemy;
event	upgradeStructures;
event	spendPower;
event	repairGrp;
event	buildFactory;
event	buildVTOLFactory;
event	sensorDroids;

/* Function prototypes */
function bool haveBeacon(int _player);
function bool beaconTimeout(int _player);
function void processCommand(string _message, int _sender, bool _bBlipMessage);
function bool haveHelpers();
function bool attemptToHelp(int _playerToHelp, int _x, int _y);
function void helpPlayer(int _playerToHelp, int _helpX, int _helpY);
function bool canStopHelpingAlly();
function void stopHelpingAlly();
function bool helpingAlly();
function bool helpAllyTimeout();
function void requestHelp(int _helpX, int _helpY);
function void doRequestHelp(int _helpX, int _helpY);
function bool allyBaseAtLoc(int _ally, int _x, int _y);
function void messagePlayer(int _playerToMessage, string _message, int _probability);
function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message);
function bool canSeeAllies();
function bool baseInTrouble();
function string m_affirmative();
function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove);
function void stopDefendingLocation();
function int nearestEnemy();
function int nearestAlly();
function bool defendingLocation();
function bool defendLocationTimeout();
function bool friendlyPlayer(int _playerToCheck);
function void factoryBuildDroid(STRUCTURE _factory);
function void cybFactorBuildCyborg(STRUCTURE _factory);
function void vtolFactoryBuildVtol(STRUCTURE _factory);
function bool insideBase(int _x, int _y);
function int numAlliesInBase(bool _bVtols);
function int numEnemiesInBase(bool _bVtols);
function bool defendingOwnBase();
function int targetTypeValue(BASEOBJ _target);
function int numBitsSet(int _integer);
function int findResearch(int _searchStart, int _techTree);
function void buildRearmPads();
function int numEnemyAAInRange(int _x, int _y, int _range);
function void buildBaseStruct(STRUCTURESTAT _structure);
function int countStruct(STRUCTURESTAT _structure);
function bool upgradeStruct(DROID _truck, int _maxBuilders, STRUCTURESTAT _struct);
function void finishStruct(STRUCTURESTAT _structure);
function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y);
function int totalVtols();
function bool needTank();
function void setTechBranch(int _tech);
function DROID closestIdleTruck(int _x, int _y);
function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat);
function void rebuildStructures();
function int numGroupSameOrder(GROUP _group, int _orderIndex);
function int numStructBusyByType(STRUCTURESTAT _busyStructType);
function bool aiResponsibleForPlayer(int _player);
function void reassignAI();
function void shutDownAI();
function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly);
function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly);
function void buildAA();
#endregion triggers

/////////////////////////////////////////////////////////////////////
// HouseKeeping
event initialisedEvent(CALL_GAMEINIT)
{
	local int player;
	// initialise
	me = getPlayer("Nexus");
	_DEBUG = FALSE;
	dbgMsgOn(me, _DEBUG);

	extraStruct = 0;
	numRepairUnits = 0;
	numSensorUnits = 0;
	allOutAttack = NULLOBJECT;

	tLastHelpRequest = -1;	//when we requested help for the last time
	lastHelpPlayer = -1;		//we are not currently helping anyone
	tHelp = -1;					//when we started helping last time
	tHelpTimeout = -1;			//time when help times out
	helpX = -1;
	helpY = -1;
	defendX = -1;
	defendY = -1;
	tDefendStart = -1;
	tDefendTimeout = -1;
	defendMoveType = -1;		//move or scout
	closestEnemy = -1;
	closestAlly = -1;
	numAllyUnits = -1;
	closestAllyDist = -1;
	
	baseRange = 4 * TILE;

	// set current research branch
	setTechBranch(-1);

	numAttackVtols = 100;	//num vtols in an attack group
	numDefendVtols = 5;	//num vtols in the defend group

	// setup build group - all initial droids are in buildgroup!
	groupAddArea(buildGroup, me, 0, 0, (mapWidth*128), (mapHeight*128));

	// note where our base is.
	getPlayerStartPosition(me, ref baseX, ref baseY);

	// defence.
	defendbusy = FALSE;

	// clear the alliance array...
	player = 0;
	while (player != MAX_PLAYERS)
	{
		allianceTime[player] = 0;
		player = player + 1;
	}

	mapSize = (float)((mapWidth + mapHeight) / 2);
	fundamentalBeingBuilt = derrick;	// to avoid ever being null
	
	if(aiResponsibleForPlayer(me))
	{
		bRunning = true;
	}
	else
	{
		bRunning = false;
		shutDownAI();
	}
	
}

// check whether we have at least one structure of that type
function bool haveStructure(STRUCTURESTAT type)
{
	return getStructure(type, me) != NULLOBJECT;
}

// check if we are getting any income
function bool havePowerSource()
{
	// we don't check buildings being finished here
	return haveStructure(powGen) and (haveStructure(derrick) or haveStructure(gderrick));
}

// I am not sure why we need this hack, but the AI can still end up not researching anything at times
event checkResearch(checkResearchTr)
{
	setEventTrigger(doResearch, chainloadTr);
}

function void dbgPlr(string message)
{
	setEventTrigger(doResearch, chainloadTr);
	if (me == selectedPlayer)
	{
		console(message);
	}
}

function void dbgObj(DROID obj, string message)
{
	if (obj.selected)
	{
		console(message);
	}
}

function bool conCanHelp(DROID mydroid, int bx, int by)
{
	return (mydroid.order != DORDER_HELPBUILD and mydroid.order != DORDER_BUILD and mydroid.order != DORDER_LINEBUILD and mydroid.order != DORDER_REPAIR and droidCanReach(mydroid, bx, by));
}

// Build something in main base, grab trucks to do it within tiles range
function bool grabTrucksAndBuild(int range, STRUCTURESTAT bstats, int maxBlockingTiles)
{
	local DROID	mydroid, closestDroid;
	local int	closestDist, currDist, numHelpDroids, tilerange, bx, by;

	initIterateGroup(buildGroup);				// find idle droids in build group.
	mydroid = iterateGroup(buildGroup);
	closestDist = 99999;
	closestDroid = NULLOBJECT;
	numHelpDroids = 0;
	tilerange = range * TILE;
	while (mydroid != NULLOBJECT)
	{
		if (conCanHelp(mydroid, baseX, baseY))
		{
			bx = baseX;
			by = baseY;
			if (pickDroidStructLocation(mydroid, bstats, ref bx, ref by, me, maxBlockingTiles))
			{
				currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y);
				if (currDist < tilerange)
				{
					orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by);	// close, so help build it
					numHelpDroids = numHelpDroids + 1;
				}
				else if (currDist < closestDist)
				{
					closestDroid = mydroid;	// record this droid as being closest so far
					closestDist = currDist;
				}
			}
		}
		mydroid = iterateGroup(buildGroup);
	}
	if (numHelpDroids == 0 and closestDroid != NULLOBJECT)	// found none within help radius, so force someone to go long distance traveling
	{
		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by);	// you, book a plane ticket and go!
		return true;
	}
	return (numHelpDroids > 0);
}


function int nearestAlly()
{
		local		int			_ally,_closestAlly,_newDist,_bestDist,_closestAllyX,_closestAllyY,_numUnits;
		local		bool		_haveTruck;
		_bestDist = 99999;
		_closestAlly = -1;
		_ally = 0;
		_numUnits = 0;
		numAlly = 0;
		while(_ally < 10)
		{
			if(allianceExistsBetween(me, _ally) and me != _ally)
			{
				numAlly = numAlly + 1;
				initEnumStruct(FALSE,playerHQ,_ally,_ally);					
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					_newDist = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
					AllyBaseY[_ally] = structure.y;
					AllyBaseX[_ally] = structure.x;
					if (_newDist < _bestDist)	
					{
						_bestDist = _newDist;
						_closestAlly = structure.player;
						_closestAllyX = structure.x;
						_closestAllyY = structure.y;
					}
					structure= enumStruct();
				}
				
				if(getStructure(playerHQ, _ally) == NULLOBJECT)
				{	
					_haveTruck = FALSE;
					InitEnumDroids(_ally,_ally);
					droid = EnumDroid();
					while (droid != NULLOBJECT and _haveTruck == FALSE)
					{
						if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT) // check to see if any of our allies don't have a truck
						{
							_haveTruck = TRUE;
							_newDist = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y);
							AllyBaseY[_ally] = droid.y;
							AllyBaseX[_ally] = droid.x;
							if (_newDist < _bestDist)	
							{
								_bestDist = _newDist;
								_closestAlly = droid.player;
								_closestAllyX = droid.x;
								_closestAllyY = droid.y;
							}
						}
						_numUnits++;
						droid = EnumDroid();
					}
				}

				
			}
			_ally++;
		}
		
		if (_bestDist != 99999)
		{
			closestAllyDist = _bestDist;
			closestAllyHQx = _closestAllyX;
			closestAllyHQy = _closestAllyY;
			numAllyUnits = _numUnits;
		}
	return _closestAlly;
}

event arrived(reachedTr)
{
	local bool found;
	local STRUCTURESTAT myChoice;
	local	STRUCTURE		_structure,_target,_allyHQ;
	local		int			_groupIndex,_newTargetWeight,_oldTargetWeight,_closestAlly;
	local 		DROID 		_droid;
	local		BASEOBJ		_newTarget;
	
	if (droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT)
	{
		dbgObj(droid, "Failed to build where we should - attempt to screw up enemy oil derrick");

		// Check if at oil well, and it was taken by enemy
		structure = structureBuiltInRange(derrick, droid.x, droid.y, (5 * 128), -1);
		_structure = structureBuiltInRange(gderrick, droid.x, droid.y, (5 * 128), -1);
		if (structure != NULLOBJECT)
		{
			if (not friendlyPlayer(structure.player))
			{
				// Ok, at enemy derrick, and nobody has hurt us yet. Start being nasty.
				count = 0;
				found = false;
				// find simplest/cheapest one available to build
				while (count < numDefStructs and not found)
				{
					if (isStructureAvailable(defStructs[count], me))
					{
						found = true;
					}
					else
					{
						count++;
					}
				}
				if (found)
				{
					buildX = droid.x;
					buildY = droid.y;
					if (pickDroidStructLocation(droid, defStructs[count], ref buildX, ref buildY, me, -1))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[count], buildX, buildY);
					}
					else
					{
						dbgObj(droid, "Wanted to be nasty, but found nowhere to build defense");
						orderDroid(droid, DORDER_RTB);		// nothing more to do here.
					}
				}
				else
				{
					dbgObj(droid, "Wanted to be nasty, but had nothing nasty to build - returning to base");
					orderDroid(droid, DORDER_RTB);		// oh, well. nothing more to do here.
				}
				exit;
			}
			else if (droid.health < 80 and !insideBase(droid.x, droid.y))
			{
				orderDroid(droid, DORDER_RTR);		// bolt back to base now!
				exit;
			}
		}
	}
	else if (isVtol(droid))
	{
		if(droid.order == DORDER_SCOUT)
		{
			orderDroidLoc(droid, DORDER_SCOUT, baseX, baseY);
		}
		
		if (droid.action == DACTION_MOVETOREARMPOINT or droid.action == DACTION_WAITFORREARM or droid.action == DACTION_MOVETOREARM or droid.action == DACTION_WAITDURINGREARM and droid.health < 75)
		{
			droidLeaveGroup(droid);
			exit;
		}
		
		if (droid.group == vtolDefendGr)
		{
			droidLeaveGroup(droid);
		}
		setDroidSecondary(droid, DSO_PATROL, DSS_PATROL_SET);
	}
}

event buildFundamentals(inactive)
{
	count = 0;
	while (count < numFundamental)
	{
		// check that struct.
		structure = getStructure(structs[count], me);
		if (structure == NULLOBJECT)				// if missing build it.
		{
			if (isStructureAvailable(structs[count], me))
			{
				if (grabTrucksAndBuild(12, structs[count], 0))
				{
					exit;	// no need to check more
				}
			}
		}
		count = count + 1;
	}
	fundamentalBeingBuilt = derrick;
	setEventTrigger(buildFundamentals, inactive);
}

event spendPower(spendPowerTr)
{
	if(getPlayerName(me) == "Nexus" || not isHumanPlayer(me))							// not human
	{
		if(playerPower(me) > 6000 and idleGroup(buildGroup) > 0)
		{	
			if (isStructureAvailable(archAngel, me))
			{
				if (grabTrucksAndBuild(12, archAngel, 0))
				{
					exit;	// no need to check more
				}
				
			}
			
			if (isStructureAvailable(rippleRocket, me))
			{
				if (grabTrucksAndBuild(12, rippleRocket, 0))
				{
					exit;	// no need to check more
				}	
			}
			count = numDefStructs - 1;
			while (count > 0)
			{
				// check that struct.

					if (isStructureAvailable(defStructs[count], me))
					{
						if (grabTrucksAndBuild(12, defStructs[count], 0))
						{
							exit;	// no need to check more
						}
					}
				count = count - 1;
			}
		}
	}
}

event startLevel(startLevelTr)
{
	setEventTrigger(buildFundamentals, slowloadTr);
	setEventTrigger(conDroids, chainloadTr);
	setEventTrigger(doResearch, chainloadTr);
	setEventTrigger(buildDerrick, delayedloadTr);
	setEventTrigger(startLevel, inactive);
	
	closestAlly = nearestAlly();
	closestEnemy = nearestEnemy();
}

// decide what technology branch we will use
function void setTechBranch(int _tech)
{
	local float		_y2,_y1,_x2,_x1,_a,_y,_m,_rnd;
	local int 		__rnd,_ally,_count;

	if(_tech != -1)
	{
		curTech = _tech;	
	}

	_ally = 0;
	_count = 0;
	while(_ally < MAX_PLAYERS)
	{
		if(allianceExistsBetween(me, _ally)){
			_count++;
		}
		_ally++;
	}

	// If shared research then use flamers for map size < 130, cannons <170 else rocket
	if(_count > 0 and multiPlayerAlliancesType == ALLIANCES_TEAMS and _count < 4)
	{	
		__rnd = random(100);
		if(mapSize < 120.0 and __rnd < 50)
		{
			curTech = branchFlameVtolLaser;
		}	
		else if(mapSize < 160.0 and __rnd < 50)
		{
			curTech = branchCannonMGMortar;
		}
		else
		{
			curTech = branchRocketMGMortar;
		}	
	}
	else
	{
		//probability to choose artillery branch for map size 90 = 0; probability for map size 200 = 55
		//build a linear function: y = ((y2 - y1) / (x2 - x1)) * x + a depending on two values given (short: y = mx+a)
		_x1 = 90.0; _y1 = 0.0;
		_x2 = 250.0; _y2 = 65.0;
		_m = ((_y2 - _y1) / (_x2 - _x1));
		_a = -(_m * _x1);

		//calculate probability for the current map
		_y = _m * mapSize + _a;

		dbg("_m = " & _m & ", a = " & _a, me);

		_rnd = (float)random(100);
		if(_rnd  < _y)
		{
			curTech = branchArtillery;
		}
		else
		{	
			// if no allies or allies with no shared research then use these profiles
			__rnd = random(16);
			if(__rnd  <= 4)
			{
				curTech = branchRocket; // 5/16 chance to select profile
			}	
			else if(__rnd >= 12)
			{
				curTech = branchCannon; // 4/16 chance to select profile
			}
			else if(__rnd <= 8)
			{
				curTech = branchMG; // 4/16 chance to select profile
			}
			else
			{
				curTech = branchFlamer; // 4/16 chance to select profile
			}
		}
	}
			// by default grenadiers are highest priority light cyborg in early game so we change that here depending on research profile
			if(curTech == branchFlamer and multiPlayerAlliancesType == ALLIANCES_UNSHARED) //prioritize flamer borgs over grenadier
			{
				cybTempl[5] = cybTempl[3];
				cybTempl[6] = cybTempl[4];
			}
			else if(curTech == branchCannon and multiPlayerAlliancesType == ALLIANCES_UNSHARED) //prioritize cannon borgs over grenadier
			{
				cybTempl[5] = cybTempl[1];
				cybTempl[6] = cybTempl[2];
			}
			else if(curTech == branchRocket or curTech == branchMG and multiPlayerAlliancesType == ALLIANCES_UNSHARED) //prioritize mg borgs over grenadier
			{
				cybTempl[5] = cybTempl[0];
				cybTempl[6] = cybTempl[0];
			}
			else if(curTech == branchFlameVtolLaser) //prioritize flamer borgs over grenadier
			{
				cybTempl[5] = cybTempl[3];
				cybTempl[6] = cybTempl[4];
			}
		//	else if(curTech == branchMG and multiPlayerAlliancesType == ALLIANCES_UNSHARED) //prioritize mg borgs over grenadier
			//{
		//		cybTempl[5] = cybTempl[0];
			//	cybTempl[6] = cybTempl[0];
			//} 

}

/* returns TRUE if AI is responsible for the _player */
function bool aiResponsibleForPlayer(int _player)
{
	if(not _DEBUG and ((_player == selectedPlayer) or not myResponsibility(_player)))
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////
// keep details about the size and postion of the ai players base
event basedetails(basedetailsTr)
{
	// clear old extremities.
	maxy = 0;
	maxx = 0;
	miny = (mapHeight*128);
	minx = (mapWidth*128);

	baseRange = 4 * TILE;

	// now find the extremities of our vital structures.
	count = 0;
	while(count < numBaseStruct)
	{
		initEnumStruct(FALSE,baseStruct[count],me,me);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.x < minx)
			{
				minx = structure.x;
			}
			if(structure.x > maxx)
			{
				maxx = structure.x;
			}
			if(structure.y < miny)
			{
				miny = structure.y;
			}
			if(structure.y > maxy)
			{
				maxy = structure.y;
			}

			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);

			if(result > baseRange){
				baseRange = result;
			}

			structure= enumStruct();
		}

		count = count + 1;
	}

	result = 3 * 128;
	minx = minx - result;
	maxx = maxx + result;
	miny = miny - result;
	maxy = maxy + result;

	baseRange = baseRange + (4 * 128);
}

event repairGrp(repairGrpTr)
{
	local bool _droidNeedRepair;
	local DROID _droid;
	
	if(repairGroup.members > 0)
	{
		_droidNeedRepair = false;
		InitEnumDroids(me,me);
		droid = EnumDroid();
		while(droid != NULLOBJECT and _droidNeedRepair == false)
		{
			initIterateGroup(repairGroup);
			_droid = iterateGroup(repairGroup);
			while(_droid != NULLOBJECT)
			{
				if(_droid.action != DACTION_DROIDREPAIR)
				{
					if(distBetweenTwoPoints(_droid.x,_droid.y,droid.x,droid.y) < (TILE * 3) and droid.health < 90)
					{
						orderDroid(_droid, DORDER_STOP);
						_droidNeedRepair = true;
					}
					else if(distBetweenTwoPoints(_droid.x,_droid.y,droid.x,droid.y) < (TILE * 6) and droid.health < 90)
					{
						orderDroidLoc(_droid, DORDER_MOVE, _droid.x,_droid.y);
						orderDroidLoc(droid, DORDER_MOVE, _droid.x,_droid.y);
						_droidNeedRepair = true;
					}
					else if(distBetweenTwoPoints(_droid.x,_droid.y,droid.x,droid.y) < (TILE * 25) and droid.health < 90)
					{
						orderDroidLoc(droid, DORDER_MOVE, _droid.x,_droid.y);
						orderDroidLoc(_droid, DORDER_MOVE, droid.x,droid.y);
						_droidNeedRepair = true;
					}
					else if(distBetweenTwoPoints(_droid.x,_droid.y,droid.x,droid.y) > (TILE * 10) and droid.health < 60)
					{
						orderDroidLoc(_droid, DORDER_MOVE, droid.x,droid.y);
						
						//if(_droid.order == DORDER_RTR)
						//{
						//	orderDroidLoc(droid, DORDER_MOVE, _droid.x,_droid.y);
						//}
						_droidNeedRepair = true;
					}
				}
				_droid = iterateGroup(repairGroup);
			}
		droid = EnumDroid();
		}
	}
}

event droidOrders(droidOrdersTr)
{
	local int _droidAtHq,_numDroids,_bestDist,_newDist,_closestRepairDroidX,_closestRepairDroidY;
	local DROID _droid,_closestRepairDroid;
	
	_droidAtHq = 0;
	
	
	InitEnumDroids(me,me);
	_droid = EnumDroid();
	while (_droid != NULLOBJECT) 
	{
		_numDroids++;
		if (!isVtol(_droid))
		{
			//if(_droid.droidType == DROID_WEAPON and distBetweenTwoPoints(_droid.x, _droid.y, closestAllyHQx, closestAllyHQy) < distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY))
			//{
			//	takeOverSingleDroid(_droid, closestAlly);
			//}
			
			if(_droid.order == DORDER_GUARD or _droid.action == DACTION_WAITFORREPAIR and _droid.droidType == DROID_WEAPON) // this prevent droids from accumulating in the base while standing around doing nothing
			{
				_droidAtHq++;
				orderDroid(_droid, DORDER_STOP);
				groupAddDroid(attackGroup, _droid);
			}
			
			if(_droid.droidType == DROID_CONSTRUCT or _droid.droidType == DROID_CYBORG_CONSTRUCT) // make sure all construction droids belong to buildGroup. If ally gives us a truck, this is how it's added to build group
			{
				groupAddDroid(buildGroup, _droid);
			}

			if(_droid.droidType == DROID_REPAIR or _droid.droidType == DROID_CYBORG_REPAIR) // sometimes repair droids in our base don't repair because they're waiting for someone to repair them. Let's check for these circumstances and reset orders if so.
			{
				groupAddDroid(repairGroup, _droid);
				if(_droid.order == DORDER_RTR)
				{
					orderDroidLoc(_droid,DORDER_MOVE,_droid.x,_droid.y);
				}
			}
			
			_bestDist = 99999;
			
			if(_droid.health < 70 and repairGroup.members > 0)  // send damaged units to nearest repair droid
			{
				initIterateGroup(repairGroup);
				droid = iterateGroup(repairGroup);
				while(droid != NULLOBJECT)
				{
					_newDist = distBetweenTwoPoints(droid.x, droid.y, _droid.x, _droid.y);
					
					if (_newDist < _bestDist and droidCanReach(_droid, droid.x, droid.y))	// this repair droid is closer
						{
							_bestDist = _newDist;
							_closestRepairDroid = droid;
							_closestRepairDroidX = droid.x;
							_closestRepairDroidY = droid.y;
						}
			
					droid = iterateGroup(repairGroup);
				}
			
				if(_closestRepairDroid != NULLOBJECT)
				{
					orderDroidLoc(_droid, DORDER_MOVE, _closestRepairDroidX, _closestRepairDroidY);
				}
			}
		}
		_droid = EnumDroid();	
	}
	
	if(_droidAtHq > 9) // if we have 10 weapon droids at the base doing nothing send them into combat. Should never have more then 10 droids in base with full health
	{
		setEventTrigger(findEnemy,chainloadTr);
	}
	else if(gameTime < 6000)
	{
		//groupAddGroup(attackGroup, defendGroup);
		setEventTrigger(findEnemy,chainloadTr);
	}
	
	if(_numDroids < 1 and getStructure(playerHQ, me) == NULLOBJECT)
	{
		setEventTrigger(enemyNearBase, inactive);
		setEventTrigger(beaconEv, inactive);
	}
	
}

event repairBase(repairBaseTr)
{
	local bool foundOne;
	local int _numFactory;
	
//	_numFactory = countStruct(factory);
//	
//	
//	if (_numFactory < 1 and buildGroup.members < 2)
//	{
//		InitEnumDroids(me,me);
//		droid = EnumDroid();
//		while (droid != NULLOBJECT) 
//		{
//			if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT) // make sure all construction droids belong to buildGroup. If ally gives us a truck, this is how it's added to build group
//			{
//				orderDroidStatsLoc(droid, DORDER_BUILD, factory, droid.x, droid.y);
//				exit;
//			}
//			droid = EnumDroid();
//		}
//	}
	
	foundOne = false;
	initIterateGroup(buildGroup);				
	droid = iterateGroup(buildGroup);
	while (droid != NULLOBJECT && !foundOne)
	{	
		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR and distBetweenTwoPoints(droid.x, droid.y,baseX,baseY) <= (15 * TILE))
		{
			foundOne = true;
		}
		else
		{
			droid = iterateGroup(buildGroup);
		}
	}
	
	if(foundOne and droid != NULLOBJECT)
	{
		initEnumStruct(TRUE,derrick,me,me);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structure.health < 100 and distBetweenTwoPoints(structure.x, structure.y,baseX,baseY) <= (15 * TILE))
			{
				orderDroidObj(droid, DORDER_REPAIR, structure);
			}
		structure= enumStruct();
		}
	}	
}

event checkOnAlly(checkOnAllyTr)
{
	local DROID _giveTruck,_droid;
	local int _powerTransfer,_allyPower,_numTruck,_myPower,_count;
	local bool _haveTruck;
	
	_count = 0;
	while(_count < 9) 
	{
		if(allianceExistsBetween(me, _count) and me != _count)
		{	
		
//			// Transfer 30% of power to ally if we have 2000 more power then ally
//			// This doesn't work because addPower() is only available in campaign - or at least it doesn't work anywhere 


			_powerTransfer = 0;			
			_myPower = playerPower(me);
			_allyPower = playerPower(_count);
			_powerTransfer = _myPower - _allyPower;
			if(_powerTransfer > 2000)
			{
				_powerTransfer = (int)(((float)playerPower(me)) * .30);
				_powerTransfer = 1000;
				addPower(_powerTransfer, _count);
				_powerTransfer = _powerTransfer * -1;
				addPower(_powerTransfer, me);
			}
	
	
			// if we have at least two trucks then give one to ally that doesn't
			// this works but logs an error in the log file that "Script interpreter is already running"
			
			_haveTruck = FALSE;
			InitEnumDroids(_count,_count);
			_droid = EnumDroid();
			while (_droid != NULLOBJECT)
			{
				if(_droid.droidType == DROID_CONSTRUCT or _droid.droidType == DROID_CYBORG_CONSTRUCT) // check to see if any of our allies don't have a truck
				{
					_haveTruck = TRUE;
				}
				_droid = EnumDroid();
			}
		
			if(!_haveTruck)
			{	
				_numTruck = 0;
				InitEnumDroids(me,me);
				_droid = EnumDroid();
				while (_droid != NULLOBJECT)
				{
					if(_droid.droidType == DROID_CONSTRUCT or _droid.droidType == DROID_CYBORG_CONSTRUCT) // check to see if we have any trucks to give
					{
						_numTruck++;
						_giveTruck = _droid;
					}
					_droid = EnumDroid();
				}
				
				if(_numTruck > 2) 
				{
					takeOverSingleDroid(_giveTruck, _count);
				}
			}
		}
		_count++;
	}	
}

/////////////////////////////////////////////////////////////////////
// structure building rules

// build derricks on oil.
event buildDerrick(buildDerrickTr)
{
	local bool	foundOne, _same,_droidInRange,_allyOil;
	local FEATURE	_oil, _closestOil,_truckRush;
	local int	_bestDist, _newDist,_furthestDist, _count,_numOil,_numEnemy, _closestOilDist, _closestDistAlly;
	local DROID	_search;
	local float _mapSize;
	local	STRUCTURE		_structure;

	// what if we can't waste power on building derricks because we don't have a gen yet?
	if (playerPower(me) < 500 and haveStructure(derrick) and not haveStructure(powGen))
	{
		setEventTrigger(buildDerrick, slowloadTr);
		exit;
	}	
	
	_numOil = 0;
	_bestDist = 99999;
	_furthestDist = 0;
	
	
	
	initGetFeature(oilRes, -1, me);
	_oil = getFeatureB(me);
	while (_oil != NULLOBJECT)
	{
		_numOil++;
		_oil = getFeatureB(me);
	}
	
	numDerricks = countStruct(derrick) + countStruct(gderrick);
			
	_truckRush = NULLOBJECT;
	_mapSize = (float)((mapWidth + mapHeight) / 2);
	if(_mapSize < 120.0 and gameTime < 3600 and numDerricks > 3)
	{
		_count = 0;
		while(_count < MAX_PLAYERS)
		{
			if(!allianceExistsBetween(me, _count))
			{
				_numEnemy++;
				initGetFeature(oilRes, -1, me);
				_oil = getFeatureB(me);
				while (_oil != NULLOBJECT)
				{	
					_droidInRange = FALSE;
					if(droidInRange(_count, _oil.x, _oil.y, (6 * TILE))) // find oil resources with enemy droid within 8 tiles. 
					{
						_truckRush = _oil;
					}
					_oil = getFeatureB(me);
				}
			}
			_count++;
		}	
	}
	
	//_closestOil = NULLOBJECT;
	foundOne = false;
	initIterateGroup(buildGroup);				
	droid = iterateGroup(buildGroup);
	while (droid != NULLOBJECT && !foundOne)
	{
		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR)
		{
			foundOne = true;
		}
		else
		{
			droid = iterateGroup(buildGroup);
		}
	}
	if (droid != NULLOBJECT)
	{
	
		initGetFeature(oilRes, -1, me);
		_oil = getFeatureB(me);
		while (_oil != NULLOBJECT)
		{
			_count = 0;
			_allyOil = false;
			while (_count < numAlly)
			{

				if(gameTime < 4200 and distBetweenTwoPoints(_oil.x, _oil.y, AllyBaseX[_count], AllyBaseY[_count]) < distBetweenTwoPoints(_oil.x, _oil.y, baseX, baseY) and distBetweenTwoPoints(_oil.x, _oil.y, baseX, baseY) > (15 * TILE))
				{
					_allyOil = true;
				}
				_count++;
			}
			if (!_allyOil)
			{
				_newDist = distBetweenTwoPoints(droid.x, droid.y, _oil.x, _oil.y);
				_same = false;
				if (_newDist < _bestDist and droidCanReach(droid, _oil.x, _oil.y))	// find closest available oil resource
				{
					if (!threatInRange(me, _oil.x, _oil.y, OIL_THREAT_RANGE, FALSE))
					{
						initIterateGroup(buildGroup);				// find all units in build group.
						_search = iterateGroup(buildGroup);
						foundOne = false;
						while (_search != NULLOBJECT && !foundOne)
						{
							if (_search.orderx == _oil.x and _search.ordery == _oil.y and _search != droid)
							{
								_same = true;
								foundOne = true;
							}
							_search = iterateGroup(buildGroup);
						}
						if (!_same)	// do not go to same spot as another droid
						{
							_bestDist = _newDist;
							_closestOil = _oil;
						}
					}
				}
			}
			_oil = getFeatureB(me);
		}
		
		if(numDerricks < 40)
		{
			if (_truckRush != NULLOBJECT) 
			{
				if(!isStructureAvailable(gTower, me))
				{
					initEnumStruct(FALSE,resLab,me,me);	
					structure= enumStruct();
					while(structure != NULLOBJECT)
					{
						pursueResearch(structure, me, guardTower);
						structure= enumStruct();
					}
				}
				
				if(isStructureAvailable(gderrick,me)) // build guarded oil derrick before ordinary oil derrick. 
				{
					if(!threatInRange(me, _truckRush.x, _truckRush.y, 1, FALSE) and distBetweenTwoPoints(baseX, baseY, _truckRush.x, _truckRush.y) > (15 * TILE))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, gderrick, _truckRush.x, _truckRush.y); // build a derick
					}
					else if(!threatInRange(me, _truckRush.x, _truckRush.y, 1, FALSE))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _truckRush.x, _truckRush.y); // build a derick
					}	
					else if(distBetweenTwoPoints(baseX, baseY, _closestOil.x, _closestOil.y) > (15 * TILE))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, gderrick, _closestOil.x, _closestOil.y); // build a derick
					}
					else
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y); // build a derick
					}
				}
				else if(!threatInRange(me, _truckRush.x, _truckRush.y, 1, FALSE))
				{
					orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _truckRush.x, _truckRush.y); // build a derick
				}
				else
				{
					orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y); // build a derick
				}
			}	
			else if (_closestOil != NULLOBJECT and count < 40) // if there are no oils with enemies around them then settle for the closest available oil
			{	
				if( isStructureAvailable(gderrick,me) and distBetweenTwoPoints(baseX, baseY, _closestOil.x, _closestOil.y) > (15 * TILE))
				{
					orderDroidStatsLoc(droid, DORDER_BUILD, gderrick, _closestOil.x, _closestOil.y); // build a derick
				}
				else
				{
					orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y); // build a derick
				}
			}
			
			if (idleGroup(buildGroup) > 0)
			{
				setEventTrigger(buildDerrick, slowloadTr);	// do it again for next droid
				exit;
			}
		}
	}
	setEventTrigger(buildDerrick, buildDerrickTr);
}


//event announceResearch(inactive)
//{
//
//	if(curTech == branchFlameVtolLaser)
//	{
//		messagePlayer(ALL_ALLIES, "I'm researching Flamers then VTOL and lasers if the game is long.", MAX_PROBABILITY);
//	}
//	else if(curTech == branchCannonMGMortar)
//	{
//		messagePlayer(ALL_ALLIES, "I'm researching Cannons, MG's and mortars. Grenadiers for cyborgs.", MAX_PROBABILITY);
//	}
//	else if(curTech == branchRocketMGMortar)
//	{
//		messagePlayer(ALL_ALLIES, "I'm researching Rocket MG's and mortars.  Grenadiers for cyborgs.", MAX_PROBABILITY);
//	}
//	else if(curTech == branchRocket)
//	{
//		messagePlayer(ALL_ALLIES, "I think I'll use rockets + MG", MAX_PROBABILITY);
//	}
//	else if(curTech ==  branchMG)
//	{
//		messagePlayer(ALL_ALLIES, "I'm researching all MG's", MAX_PROBABILITY);
//	}
//	else if(curTech == branchFlamer)
//	{
//		messagePlayer(ALL_ALLIES, "I'm going all flamers", MAX_PROBABILITY);
//	}
//	else if(curTech == branchCannon)
//	{
//		messagePlayer(ALL_ALLIES, "I'm using cannons this game", MAX_PROBABILITY);
//	}
//	else if(curTech == branchArtillery)
//	{
//		messagePlayer(ALL_ALLIES, "I'm researching Mortars and Artillery Research", MAX_PROBABILITY);	
//	}
//	setEventTrigger(announceResearch,	inactive);
//}

/////////////////////////////////////////////////////////////////////
// if idle and derrick in range and no defense then build defense, else ret to base .
event buildOilDefenseOrRetreat(buildOilDefenseOrRetreatTr)
{
	local	int		_numBuilders,_maxBuilders;
	local	STRUCTURE		_structure;

	_maxBuilders = 1;

	// check idle.
	initIterateGroup(buildGroup);					// find idle droids in build group.
	droid = iterateGroup(buildGroup);
	while(droid != NULLOBJECT)
	{
		if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR)
		{
			// if in range of a derrick
			structure = structureBuiltInRange(derrick, droid.x, droid.y, (5*128), me);
			_structure = structureBuiltInRange(gderrick, droid.x, droid.y, (5*128), me);
			
			// if inside base limits then presume ok..
			if( structure != NULLOBJECT)
			{
				if((structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y <maxy))
				{
					structure = NULLOBJECT;
				}
			}
			
			// if inside base limits then presume ok..
			if( _structure != NULLOBJECT)
			{
				if((_structure.x > minx) and (_structure.y > miny) and (_structure.x < maxx) and (_structure.y <maxy))
				{
					_structure = NULLOBJECT;
				}
			}

			if(_structure != NULLOBJECT)
			{
				buildX = _structure.x;
				buildY = _structure.y;

				// not many defenses nearby
				if(numFriendlyWeapStructsInRange(me, buildX, buildY, (3*128), FALSE) < 2)
				{
					count = numDefStructs - 1;							//pick a struct to build..
					count2 = 0;
					while( (count2 < 5) and (count >= 0) )
					{
						if( isStructureAvailable(defStructs[count],me))
						{
							structChoice[count2] = defStructs[count];
							count2 = count2 + 1;
						}
						count = count - 1;
					}
					count =0;
					if(count2 > 0)
					{
						count = random(count2);						 //count = choice!

						// pick a location
						boolResult = pickDroidStructLocation(droid, structChoice[count], ref buildX, ref buildY, me, -1);

						_numBuilders = numBuildSameBuilding(NULLSTRUCTURESTAT, buildX, buildY);

						if((boolResult == TRUE) and (_numBuilders < _maxBuilders) and droidCanReach(droid, buildX, buildY))
						{
							// build it.
							orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
							_numBuilders++;
						}
					}
				}
				else
				{
					_structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
					if(_structure == NULLOBJECT)
					{
						if(!insideBase(droid.x, droid.y))
						{
							orderDroid(droid,DORDER_RTB);				// return to base;
						}
					}
				}
			}
			else
			{
				_structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
				if(_structure == NULLOBJECT)
				{
					if(!insideBase(droid.x, droid.y))
					{
						orderDroid(droid,DORDER_RTB);					// return to base;
					}
				}
			}
			
			if(structure != NULLOBJECT)
			{
				buildX = structure.x;
				buildY = structure.y;

				// not many defenses nearby
				if(numFriendlyWeapStructsInRange(me, buildX, buildY, (3*128), FALSE) < 2)
				{
					count = numDefStructs - 1;							//pick a struct to build..
					count2 = 0;
					while( (count2 < 5) and (count >= 0) )
					{
						if( isStructureAvailable(defStructs[count],me))
						{
							structChoice[count2] = defStructs[count];
							count2 = count2 + 1;
						}
						count = count - 1;
					}
					count =0;
					if(count2 > 0)
					{
						count = random(count2);						 //count = choice!

						// pick a location
						boolResult = pickDroidStructLocation(droid, structChoice[count], ref buildX, ref buildY, me, -1);

						_numBuilders = numBuildSameBuilding(NULLSTRUCTURESTAT, buildX, buildY);

						if((boolResult == TRUE) and (_numBuilders < _maxBuilders) and droidCanReach(droid, buildX, buildY))
						{
							// build it.
							orderDroidStatsLoc(droid, DORDER_BUILD,structChoice[count], buildX,buildY);
							_numBuilders++;
						}
					}
				}
				else
				{
					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
					if(structure == NULLOBJECT)
					{
						if(!insideBase(droid.x, droid.y))
						{
							orderDroid(droid,DORDER_RTB);				// return to base;
						}
					}
				}
			}
			else
			{
				structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5*128), me);
				if(structure == NULLOBJECT)
				{
					if(!insideBase(droid.x, droid.y))
					{
						orderDroid(droid,DORDER_RTB);					// return to base;
					}
				}
			}
		}
		droid = iterateGroup(buildGroup);
	}
}

/////////////////////////////////////////////////////////////////////
//mortar etc.. rules. build sensor towers and emplacements.
event incendry(incendryTr)
{
	local	INT		_count,_bestDist, _newDist,_closestX,_closestY,_enemy;
	local 	DROID   _closestTruck;
	local	STRUCTURE	_resFac,_powGen;
	local 	bool 	_needModule;
	
	if (not isStructureAvailable(sensorTower, me) or (playerPower(me) < MIN_BUILDPOWER_ARTILLERY))
	{
		exit;
	}
	
	if(curTech != branchArtillery and curTech != branchCannonMGMortar and curTech != branchRocketMGMortar)
	{
		exit;
	}

	_needModule = FALSE;
	
	initEnumStruct(FALSE,powGen,me,me);		// these check if power or research modules can be built before going all out on artillery. Otherwise might not finish base.
	_powGen= enumStruct();
	while(_powGen != NULLOBJECT)
	{
		if(!testStructureModule(me, _powGen, 0))
		{
			_needModule = TRUE;
			_powGen = NULLOBJECT;
		}
		_powGen= enumStruct();
	}
	
	initEnumStruct(FALSE,resLab,me,me);
	_resFac= enumStruct();
	while(_resFac != NULLOBJECT)
	{
		if(!testStructureModule(me, _resFac, 0))
		{
			_needModule = TRUE;
			_resFac = NULLOBJECT;
		}
		_resFac= enumStruct();
	}

	if(_needModule == TRUE)
	{
		exit;
	}

	count = countStruct(sensorTower);
	
	if (count < (gameTime/3000))		// every 5 mins
	{
		// if not found build a sensor tower.
		// find a place to build.
		buildX = 0;
		buildY = 0;
		initEnumStruct(FALSE,derrick,me,me);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			count = 0;
			result = 0;
			while(count < numDefStructs)
			{
				structure2 = structureBuiltInRange(defStructs[count], structure.x, structure.y,(4*128), me);
				if(structure2 != NULLOBJECT)
				{
					result = result + 1;
				}
				count = count + 1;
			}

			// check for sensor nearby,
			structure2 = structureBuiltInRange(sensorTower, structure.x, structure.y,(5*128), me);
			if(structure2 != NULLOBJECT)
			{
				result = 4;
			}

			if(result < 3)
			{
				buildX = structure.x;
				buildY = structure.y;
				structure = NULLOBJECT;
			}
			else
			{
				structure = enumStruct();
			}
		}

		if(buildX != 0)
		{
			boolResult = pickStructLocation(sensorTower, ref buildX, ref buildY,me);	// pick spot.
			if(boolResult == TRUE)
			{
				// find unit
				initIterateGroup(buildGroup);
				droid = iterateGroup(buildGroup);
				while(droid != NULLOBJECT)
				{
					if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
					{
						orderDroidStatsLoc(droid, DORDER_BUILD, sensorTower, buildX, buildY);
						droid = NULLOBJECT;
					}
					else
					{
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
	else
	{
		// find a sensor tower with least incendry structs around it..
		buildX = 0;
		buildY = 0;

		initEnumStruct(FALSE,sensorTower,me,me);
		structure= enumStruct();
		count = 999;
		while(structure != NULLOBJECT)
		{
			// count incendrys near this tower.
			result = 0;
			count2 = 0;
			while(count2 < numIncendrys)
			{
				structure2 = structureBuiltInRange(incendrys[count2], structure.x, structure.y,(4*128), me);
				if(structure2 != NULLOBJECT)
				{
					result = result + 1;
				}
				count2 = count2 + 1;
			}

			if((result < 12) and (result < count))		// lowest found yet. only sites with <6 too.
			{
				buildX = structure.x;
				buildY = structure.y;
				count  = result;
			}
			structure = enumStruct();
		}

		if(buildX != 0)
		{

			// choose a device
			count = numIncendrys - 1;
			result = 99;
			while(count >= 0 )
			{
				if(isStructureAvailable(incendrys[count],me))
				{
					result = count;
					count = -1;
				}
				else
				{
					count = count - 1;
				}
			}


			// find a unit and build an incendry device.
			if(result != 99)
			{
				boolResult = pickStructLocation(incendrys[result], ref buildX, ref buildY,me);	// pick spot.
				if(boolResult == TRUE)
				{
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);

					boolResult = (numBuildSameBuilding(incendrys[result], buildX, buildY) > 0);	//anyone building there already?

					while(droid != NULLOBJECT and (not boolResult))
					{
						if ((droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD,incendrys[result], buildX,buildY);
							boolResult = TRUE;	//only 1 truck
						}
						droid = iterateGroup(buildGroup);
					}
				}
			}
		}
	}
}

// BUILD POWER GENERATOR FOR EVERY 4 DERRICKS - VITAL!
event buildPowerGenerators(buildPowerGeneratorsTr)
{
	numDerricks = countStruct(derrick) + countStruct(gderrick);
	numPowerGen = countStruct(powGen);
	
	if((numPowerGen * 4) < numDerricks)								// if we need powergen
	{
		buildBaseStruct(powGen);
	}
}

// BUILD RESEARCH CENTER FOR EVERY 4 DERRICKS
event buildReCenters(buildReCentersTr)
{
	if (!isStructureAvailable(resLab, me) or (playerPower(me) < MIN_BUILDPOWER_RESCENTER))
	{
		exit;
	}
	
	numDerricks = countStruct(derrick) + countStruct(gderrick);
	numResearchLab = countStruct(resLab);
	
	if((numResearchLab * 4) < numDerricks or playerPower(me) > 2000)								// if we need research center
	{
		buildBaseStruct(resLab);
	}
}


// BUILD FACTORY FOR EVERY 5 DERRICKS
event buildFactory(buildFactoryTr)
{
	if (!isStructureAvailable(factory, me) or (playerPower(me) < MIN_BUILDPOWER_FACTORY))
	{
		exit;
	}
	
	numDerricks = countStruct(derrick) + countStruct(gderrick);
	numFactory = countStruct(factory);
	
	if((numFactory * 5) < numDerricks or playerPower(me) > 4000)								// if we need factory
	{
		buildBaseStruct(factory);
	}
}

// BUILD CYBORG FACTORY FOR EVERY 5 DERRICKS
event buildCyFactory(buildCyFactoryTr)
{
	if (!isStructureAvailable(cybFactory, me) or (playerPower(me) < MIN_BUILDPOWER_CYBFACTORY))
	{
		exit;
	}
	
	numDerricks = countStruct(derrick) + countStruct(gderrick);
	numCybFactory = countStruct(cybFactory);
	
	if((numCybFactory * 5) < numDerricks or playerPower(me) > 3000)								// if we need cyborg factory
	{
		buildBaseStruct(cybFactory);
	}
}

// BUILD VTOL FACTORY FOR EVERY 5 DERRICKS
event buildVTOLFactory(buildVTOLFactoryTr)
{
	if (!isStructureAvailable(vtolFactory, me) or (curTech != branchFlamer and curTech != branchFlameVtolLaser and (playerPower(me) < MIN_BUILDPOWER_VTOLFACTORY)) or gameTime < 3000)
	{
		exit;
	}

	numDerricks = countStruct(derrick) + countStruct(gderrick);
	numVtolFactory = countStruct(vtolFactory);
	
	if((numVtolFactory * 5) < numDerricks or playerPower(me) > 6000)								// if we need VTOL factory
	{
		buildBaseStruct(vtolFactory);
	}
}


function void buildBaseStruct(STRUCTURESTAT _structure)
{
		local	INT		_count,_bestDist, _newDist,_closestX,_closestY,_buildX,_buildY;
		local 	DROID   _closestTruck;
		local   bool    _proceed;
		
		_closestX = 0;
		_closestY = 0;
		_bestDist = 99999;
		_buildX = buildX;
		_buildY = buildY;
		_proceed = false;
	
	if(getPlayerName(me) == "Nexus" || not isHumanPlayer(me))							// not human
	{
			initIterateGroup(buildGroup);
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if(_structure == powGen and countStruct(powGen) < 3 and gameTime > 1400) // prioritize power generators over other base structures even if building other structure except for first 2 minutes of game (screws up base build)
				{
					_proceed = true;
				}
				else if(droid.order != DORDER_HELPBUILD and droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR)
				{
					_proceed = true;
				}
				else
				{
					_proceed = false;
				}
				
				if(_proceed)
				{
					_count = 1;
					while(_count < 10)
					{
							_buildX = baseX + _count;
							_buildY = baseY + _count;
							if (pickDroidStructLocation(droid, _structure, ref _buildX, ref _buildY, me, 1))
							{
								_newDist = distBetweenTwoPoints(droid.x, droid.y, _buildX, _buildY);
						
								if (_newDist < _bestDist and droidCanReach(droid, _buildX, _buildY))	// this one is closer
								{
									_bestDist = _newDist;
									_closestX = _buildX;
									_closestY = _buildY;
									_closestTruck = droid;
								}
							}
							
							_buildY = baseY + (_count * -1);
							if(_buildY > 0 and _buildY < mapHeight)
							{
							if (pickDroidStructLocation(droid, _structure, ref _buildX, ref _buildY, me, 1))
							{
								_newDist = distBetweenTwoPoints(droid.x, droid.y, _buildX, _buildY);
						
								if (_newDist < _bestDist and droidCanReach(droid, _buildX, _buildY))	// this one is closer
								{
									_bestDist = _newDist;
									_closestX = _buildX;
									_closestY = _buildY;
									_closestTruck = droid;
								}
							}
							}
							
							_buildX = baseX + (_count * -1);
							if(_buildX > 0 and _buildX < mapWidth)
							{
							if (pickDroidStructLocation(droid, _structure, ref _buildX, ref _buildY, me, 1))
							{
								_newDist = distBetweenTwoPoints(droid.x, droid.y, _buildX, _buildY);
						
								if (_newDist < _bestDist and droidCanReach(droid, _buildX, _buildY))	// this one is closer
								{
									_bestDist = _newDist;
									_closestX = _buildX;
									_closestY = _buildY;
									_closestTruck = droid;
								}
							}
							}
							
							_buildY = baseY + (_count * -1);
							if(_buildY > 0 and _buildY < mapHeight)
							{
							if (pickDroidStructLocation(droid, _structure, ref _buildX, ref _buildY, me, 1))
							{
								_newDist = distBetweenTwoPoints(droid.x, droid.y, _buildX, _buildY);
						
								if (_newDist < _bestDist and droidCanReach(droid, _buildX, _buildY))	// this one is closer
								{
									_bestDist = _newDist;
									_closestX = _buildX;
									_closestY = _buildY;
									_closestTruck = droid;
								}
							}
							}
							_count++;
						}
				}
				droid = iterateGroup(buildGroup);
			}
			
			if (pickDroidStructLocation(_closestTruck, _structure, ref _closestX, ref _closestY, me, 1) and _closestTruck != NULLOBJECT)
			{
				orderDroidStatsLoc(_closestTruck, DORDER_BUILD, _structure, _closestX, _closestY);
			}
		}
}

/////////////////////////////////////////////////////////////////////
// ensure we have everything in the vital structs list.
event buildBase(buildBaseTr)
{
	if (idleGroup(buildGroup) >= (buildGroup.members / 2))
	{
		count = 0;
		while(count < numStructs)
		{
			// check that struct.
			structure = getStructure(structs[count],me);
			if(structure == NULLOBJECT)				// if missing build it.
			{
				if(isStructureAvailable(structs[count],me))
				{
					if (grabTrucksAndBuild(12, structs[count], 0))
					{
						exit;	// done here
					}
				}
			}
			count = count + 1;
		}
	}
}



/////////////////////////////////////////////////////////////////////
//	Structure (fac/res/pow) upgrades
event upgradeStructures(upgradeStructuresTr)
{

	initIterateGroup(buildGroup);				// find idle droids in build group.
	droid = iterateGroup(buildGroup);
	while(droid != NULLOBJECT)
	{
		if ((droid.order != DORDER_BUILD) and (droid.order != DORDER_LINEBUILD) and (droid.order != DORDER_HELPBUILD) and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR)
		{
			boolResult = FALSE;

			if(droid.order != DORDER_BUILD and droid.action != DACTION_BUILD){
			boolResult = upgradeStruct(droid, 4, powGen);
			}

			if (isStructureAvailable(facModule,me) and numDerricks < 3 and gameTime < 3000) 
			{
				setEventTrigger(upgradeStructures, upgradeStructuresTr);
				exit;
			}
			
			if(droid.order != DORDER_BUILD and droid.action != DACTION_BUILD){
				boolResult = upgradeStruct(droid, 4, resLab);
			}

			if(droid.order != DORDER_BUILD and droid.action != DACTION_BUILD){
				boolResult = upgradeStruct(droid, 4, factory);
			}
			
			if(droid.order != DORDER_BUILD and droid.action != DACTION_BUILD){
				boolResult = upgradeStruct(droid, 4, vtolFactory);
			}
		}
		droid = iterateGroup(buildGroup);
	}
}

function bool upgradeStruct(DROID _truck, int _maxBuilders, STRUCTURESTAT _struct)
{
	local	STRUCTURE	_structure,_closestStruct;
	local   STRUCTURESTAT 	_moduleType;
	local bool	foundOne;
	local int	_bestDist, _newDist;
	local DROID	_search;
	
	if(_struct == factory)
	{
		_moduleType = facModule;
	}
	else if(_struct == resLab)
	{
		_moduleType = resModule;
	}
	else if(_struct == vtolFactory)
	{
		_moduleType = facModule;
	}
	else if(_struct == powGen)
	{
		_moduleType = powModule;
	}
	
	if(!isStructureAvailable(_moduleType,me))
	{
		return FALSE;
	}
	
	_bestDist = 99999;
	initEnumStruct(FALSE,_struct,me,me);
	_structure= enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(not testStructureModule(me, _structure, 0) and droidCanReach(_truck, _structure.x, _structure.y))
		{
			_newDist = distBetweenTwoPoints(_truck.x, _truck.y, _structure.x, _structure.y);

			if (_newDist < _bestDist and droidCanReach(_truck, _structure.x, _structure.y))	// this one is closer
			{
				_bestDist = _newDist;
				_closestStruct = _structure;
			}
		}
		_structure = enumStruct();
	}
	
	if(_closestStruct != NULLOBJECT)
	{
		if((numBuildSameBuilding(_struct, _closestStruct.x,_closestStruct.y) +
		numBuildSameBuilding(_struct, _closestStruct.x,_closestStruct.y)) < _maxBuilders)
		{
			orderDroidStatsLoc(_truck, DORDER_BUILD, _moduleType, _closestStruct.x,_closestStruct.y);	// upgrade it.
			return TRUE;
		}
	}	
	return FALSE;
}

function void finishStruct(STRUCTURESTAT _structure)
{
	initEnumStruct(TRUE,_structure,me,me);
	structure= enumStruct();
	while(structure != NULLOBJECT)
	{
		if(not structureComplete(structure))
		{
			initIterateGroup(buildGroup);				// find idle droids in build group.
			droid = iterateGroup(buildGroup);
			while(droid != NULLOBJECT)
			{
				if (droid.order != DORDER_BUILD and droid.order != DORDER_HELPBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR
				    and droidCanReach(droid, structure.x, structure.y )
				    and distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y) < 12 * TILE)
				{
					orderDroidObj(droid,DORDER_HELPBUILD,structure);
				}
				droid = iterateGroup(buildGroup);
			}
		}
		structure= enumStruct();
	}	
}

/////////////////////////////////////////////////////////////////////
//	Finish Building Part Built Structures
event finishStructs(finishStructsTr)
{
	finishStruct(powGen);
	finishStruct(resLab);
	finishStruct(factory);
}


/////////////////////////////////////////////////////////////////////
//  fortify base by builiding defensive structs on the edge of the base.
// rewrote fortify to use scrSkDefenseLocation(baseX,baseY,me);

event newfortify(fortifyTr)
{
	local	int		_numBuilders,_maxBuilders,_count;

	_maxBuilders = 1;

	if(playerPower(me) > 10000 and idleGroup(buildGroup) > 2)
	{
		
		numDerricks = countStruct(derrick) + countStruct(gderrick);
		
		if(playerPower(me) < MIN_BUILDPOWER_DEFENSE or numDerricks < 6)
		{
			exit;
		}

		boolResult = FALSE;
		initIterateGroup(buildGroup);				// find idle an idle veh.in build group.
		droid = iterateGroup(buildGroup);
		while(droid != NULLOBJECT)
		{
			if (droid.order != DORDER_BUILD and droid.order != DORDER_LINEBUILD and droid.order != DORDER_HELPBUILD and droid.action != DACTION_BUILD and droid.order != DORDER_REPAIR)
			{
				tempx = baseX;
				tempy = baseY;

				count = numDefStructs - 1;
				count2 = 0;
				while( (count2 < 3) and (count >= 0) )
				{
					if( isStructureAvailable(defStructs[count],me))
					{
						structChoice[count2] = defStructs[count];
						count2 = count2 + 1;
					}
					count = count - 1;
				}
				
				count = 0;
				if(count2 > 0)
				{
					count = random(count2);
					skDefenseLocationB(ref tempx,ref tempy,wall,structChoice[count],droid,me);
				}

			}
			droid = iterateGroup(buildGroup);
		}
		
		
		
		if(playerPower(me) > 10000 and idleGroup(buildGroup) > 2)
		{
			setEventTrigger(newfortify, slowloadTr);	// do it again for next droid
		}	
	}
}


/////////////////////////////////////////////////////////////////////
// droid building rules
/////////////////////////////////////////////////////////////////////
// deal with a droid being built
event droidBuiltAssign(droidBuiltTr)
{
	setDroidSecondary(droid, DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS);
	if(isVtol(droid))
	{
		setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_LOW);
		if(vtolDefendGr.members < numDefendVtols)
		{
			groupAddDroid(vtolDefendGr, droid);
		}
		else
		{
			groupAddDroid(vtolAttackGr, droid);
		}
	}
	else if((droid.droidType != DROID_TRANSPORTER) and (droid.droidType != DROID_COMMAND))
	{
		setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_LOW);
		if((droid.droidType == DROID_REPAIR) or (droid.droidType == DROID_CYBORG_REPAIR))
		{
			numRepairUnits = numRepairUnits + 1;
			groupAddDroid(repairGroup, droid);
			if(numRepairUnits < 6)
			{
				setEventTrigger(repairDroids,chainloadTr);
			}
		}
		if(droid.droidType == DROID_SENSOR)
		{
			numSensorUnits = numSensorUnits + 1;
		}
		if((droid.droidType == DROID_CONSTRUCT) or (droid.droidType == DROID_CYBORG_CONSTRUCT))
		{
			groupAddDroid(buildGroup, droid);
		}
		else
		{
			if(droid.droidType == DROID_CYBORG)
			{
				groupAddDroid(attackGroup, droid);
			}
			else
			{
				if(attackGroup.members < numAttackers[curTech])
				{
					groupAddDroid(attackGroup, droid);
				}
				
				else if(defendGroup.members < numDefenders[curTech])
				{
					groupAddDroid(defendGroup, droid);
				}
				else 
				{
					if(attackGroup.members < maxAttackers[curTech])
					{
						groupAddDroid(attackGroup, droid);
					}
					else 
					{
						groupAddDroid(defendGroup, droid);
					}
				}
			}
		}
	}
}

//When droid built: check emergency jobs, start building next droid
event droidBuilt(droidBuiltTr)
{
	local STRUCTURE _fundie;
	local int _numBuilding,_haveTrucks,_totalTrucks;
	
	/* Start building next droid */
	if(structure != NULLOBJECT)
	{
		if(structure.stattype == REF_VTOL_FACTORY and playerPower(me) > MIN_PRODUCTIONPOWER_VTOLFACTORY)
		{
			vtolFactoryBuildVtol(structure);
		}
		else
		{
			_haveTrucks = buildGroup.members;
			_numBuilding = numTemplatesInProduction(constructor,me);
			_numBuilding = _numBuilding + numTemplatesInProduction(cybEngineer,me);	
			_totalTrucks = _numBuilding + _haveTrucks;
				
			if(gameTime < 1200)
			{
				setEventTrigger(conDroids, chainloadTr);	// consider building more
			}
			else if(_totalTrucks < MIN_TRUCKS)
			{
				setEventTrigger(conDroids, chainloadTr);	// consider building more
			}
			else if(_totalTrucks < 10 and gameTime > 3000)
			{
				setEventTrigger(conDroids, chainloadTr);	// consider building more	
			}
			// Continue building new droids right away
			else if(structure.stattype == REF_FACTORY and playerPower(me) > MIN_PRODUCTIONPOWER_FACTORY)
			{
				factoryBuildDroid(structure);
			}
			else if(structure.stattype == REF_CYBORG_FACTORY and playerPower(me) > MIN_PRODUCTIONPOWER_CYBFACTORY)
			{
				cybFactorBuildCyborg(structure);
			}
		}
	}
}

/* Gets triggered when structure was built */
event structBuilt(structBuiltTr)
{
	local	FEATURE	_oilResource;
	local	int		_count,_count2,_bestDist,_newDist,_closestX,_closestY;
	local 	DROID	_myTruck,_closestTruck;
	local   STRUCTURE _enemyDerrick;

	if (structure == NULLOBJECT || droid == NULLOBJECT)
	{
		exit;
	}

	/* factory or factory module */
	if(structure.stattype == REF_FACTORY)
	{
		if (isStructureAvailable(facModule, me) and (skGetFactoryCapacity(structure) < 2 ) and (getDroidCount(me) > 4) and gameTime > 1800)
		{
			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
		}
		else
		{
			setEventTrigger(conDroids, chainloadTr);
		}
	}
	/* vtol factory or vtol factory module */
	else if(structure.stattype == REF_VTOL_FACTORY)
	{
		if( isStructureAvailable(facModule,me) and (skGetFactoryCapacity(structure) < 2 ) and gameTime > 1800)
		{
			orderDroidStatsLoc(droid, DORDER_BUILD,facModule, structure.x,structure.y);	// upgrade it.
		}
	}
	else if(structure.stattype == REF_RESOURCE_EXTRACTOR or structure.stat == gderrick)
	{
				if(droidInRange(me, structure.x, structure.y, (16 * TILE)) and distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) > (16 * TILE))
				{	
					_bestDist = 99999;
					initIterateGroup(buildGroup);
					droid = iterateGroup(buildGroup);
					while(droid != NULLOBJECT)
					{
						_newDist = distBetweenTwoPoints(droid.x, droid.y, structure.x, structure.y);
					
						if (_newDist < _bestDist)	// this one is closer
						{
							_closestTruck = droid;
							_closestX = droid.x;
							_closestY = droid.y;
						}
						droid = iterateGroup(buildGroup);
					}	
				}
				
				if(not friendlyPlayer(structure.player))
				{
					if(_closestTruck != NULLOBJECT)
					{
						if (pickDroidStructLocation(_closestTruck, gTower, ref _closestX, ref _closestY, me, 1))
						{
							orderDroidStatsLoc(_closestTruck, DORDER_BUILD, gTower, _closestX, _closestY);
						}
					}
				}	
				
				if(structure.player == me)
				{
					
					_enemyDerrick = structureBuiltInRange(derrick, structure.x, structure.y, (12 * TILE), closestEnemy);
					
					if(_enemyDerrick != NULLOBJECT)
					{
						if(!threatInRange(me, _enemyDerrick.x, _enemyDerrick.y, (10 * TILE), FALSE) and droidCanReach(_closestTruck, _enemyDerrick.x, _enemyDerrick.y))
						{
							buildX = _enemyDerrick.x;
							buildY = _enemyDerrick.y;
							
							if (pickDroidStructLocation(_closestTruck, gTower, ref buildX, ref buildY, me, 1))
							{
								orderDroidStatsLoc(_closestTruck, DORDER_BUILD, gTower, buildX, buildY);
							}
						}
					}
					else if(distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) > (20 * TILE) and gameTime > 3000)
					{
						buildX = structure.x;
						buildY = structure.y;
						if (pickDroidStructLocation(_closestTruck, gTower, ref buildX, ref buildY, me, 1))
						{
							orderDroidStatsLoc(_closestTruck, DORDER_BUILD, gTower, structure.x, structure.y);
						}
					}
				}
		setEventTrigger(buildDerrick, chainloadTr);
		exit;
	}
	else if (structure.stattype == REF_RESEARCH)
	{
		if (isStructureAvailable(resModule, me) and gameTime > 1800)
		{
			orderDroidStatsLoc(droid, DORDER_BUILD, resModule, structure.x, structure.y);	// upgrade it.
		}
		else
		{
			setEventTrigger(doResearch, chainloadTr);
		}
	}
	else if (structure.stattype == REF_POWER_GEN)
	{
		if (isStructureAvailable(powModule, me))
		{
			orderDroidStatsLoc(droid, DORDER_BUILD, powModule, structure.x, structure.y);	// upgrade it.
		}
	}

	// Check if available trucks need to build more absolute necessities right away. We need a trigger here because
	// droids involved in building have not yet come out of their build orders.
	setEventTrigger(buildFundamentals, slowloadTr);

	//see if we have just rebuilt a destroyed structure
	_count = 0;
	while(_count < countRebuildStruct)
	{
		if(structure.x == rebuildStructX[_count] and
		   structure.y == rebuildStructY[_count] and
		   ( (structure.stat == rebuildStructStat[_count]) or //walls can end up as corner walls
		   ( (structure.stat == wall or structure.stat == cornerWall) and
		   (rebuildStructStat[_count] == wall or rebuildStructStat[_count] == cornerWall))
		   ))
		{
			dbg("finished rebuilding destroyed structure - " & _count, me);

			//resort destroyed structures
			_count2 = _count;
			while(_count2 < (countRebuildStruct - 1))
			{
				rebuildStructX[_count2] = rebuildStructX[_count2 + 1];
				rebuildStructY[_count2] = rebuildStructY[_count2 + 1];
				rebuildStructStat[_count2] = rebuildStructStat[_count2 + 1];

				_count2++;
			}

			//clear last entry
			rebuildStructX[countRebuildStruct - 1] = 0;
			rebuildStructY[countRebuildStruct - 1] = 0;
			rebuildStructStat[countRebuildStruct - 1] = NULLSTRUCTURESTAT;

			countRebuildStruct--;	//we just built one structure

			//_count = countRebuildStruct;	//exit outer loop
		}
		_count++;
	}
	if(playerPower(me) > 6000 and idleGroup(buildGroup) > 0)
	{
		setEventTrigger(spendPower, delayedloadTr);
	}
	
}


event enemyNearBase(enemyNearBaseTr)
{
	local DROID _enemy;
	local int _count,_targetX,_targetY,_findEnemyX,_findEnemyY;
	local bool _droidInRange,_beacon;
	
	_count = 0;
	while(_count < 10) 
	{
		if(!allianceExistsBetween(me, _count))
		{
			_droidInRange = FALSE;
			if(droidInRange(_count, baseX, baseY, (40 * TILE))) // find enemy droids within 70 tiles below and to the right of our base
			{
				_findEnemyY = baseY + (40 * TILE);
				_findEnemyX = baseX + (40 * TILE);
				//Positive X, Positive Y
				if(_findEnemyY > 0 and _findEnemyY < (mapHeight * TILE) and _findEnemyX > 0 and _findEnemyX < (mapWidth * TILE))
				{
					_enemy = droidTargetInArea(_count, me, baseX, baseY, _findEnemyX, _findEnemyY);
					if (_enemy != NULLOBJECT)
					{
						if(!isVtol(_enemy))
						{
							_droidInRange = TRUE;
							_targetX = _enemy.x;
							_targetY = _enemy.y;
						}
					}
				}
				
				//Positive X, Negative Y
				_findEnemyY = baseY + (40 * TILE * -1); // find enemy droids within 30 tiles above and to the right of our base
				if(_findEnemyY > 0 and _findEnemyY < (mapHeight * TILE))
				{
					_enemy = droidTargetInArea(_count, me, baseX, baseY, _findEnemyX, _findEnemyY);
					if (_enemy != NULLOBJECT)
					{
						if(!isVtol(_enemy))
						{
							_droidInRange = TRUE;
							_targetX = _enemy.x;
							_targetY = _enemy.y;
						}
					}
				}
					
				// Negative X, Negative Y
				_findEnemyX = baseX + (40 * TILE * -1); // find enemy droids within 30 tiles above and to the left of our base
				if(_findEnemyX > 0 and _findEnemyX < (mapWidth * TILE))
				{
					_enemy = droidTargetInArea(_count, me, baseX, baseY, _findEnemyX, _findEnemyY);
					if (_enemy != NULLOBJECT)
					{
						if(!isVtol(_enemy))
						{
							_droidInRange = TRUE;
							_targetX = _enemy.x;
							_targetY = _enemy.y;
						}
					}
				}
				
				// Negative X, Positive Y
				_findEnemyY = baseY + (40 * TILE * -1); // find enemy droids within 50 tiles below and to the left of our base
					
				if(_findEnemyY > 0 and _findEnemyY < (mapHeight * TILE))
				{
					_enemy = droidTargetInArea(_count, me, baseX, baseY, _findEnemyX, _findEnemyY);
					if (_enemy != NULLOBJECT)
					{
						if(!isVtol(_enemy))
						{
							_droidInRange = TRUE;
							_targetX = _enemy.x;
							_targetY = _enemy.y;
						}
					}
				}
				//setEventTrigger(findEnemy,attackStuffTr);
			}

		}	
	
		if(_droidInRange)
		{
			initIterateGroup(vtolAttackGr);
			droid = iterateGroup(vtolAttackGr);
			while(droid != NULLOBJECT)
			{	
				if(droid.health > 85)
				{
					setDroidSecondary(droid, DSO_PATROL, DSS_PATROL_SET);
					orderDroidLoc(droid,DORDER_SCOUT,_targetX, _targetY);
				}
				droid = iterateGroup(vtolAttackGr);	
			}
			
			initIterateGroup(vtolDefendGr);
			droid = iterateGroup(vtolDefendGr);
			while(droid != NULLOBJECT)
			{	
				if(droid.health > 85)
				{
					setDroidSecondary(droid, DSO_PATROL, DSS_PATROL_SET);
					orderDroidLoc(droid,DORDER_SCOUT,_targetX, _targetY);
				}
				droid = iterateGroup(vtolDefendGr);	
			}
			
			if(distBetweenTwoPoints(baseX, baseY, _targetX, _targetY) <  40 * TILE)
			{
				orderGroupLoc(attackGroup, DORDER_SCOUT,_targetX, _targetY);
				if (haveStructure(playerHQ))
				{
					count = 0;
					while (count < 10) 
					{
						if(allianceExistsBetween(me, count))
						{	
							if((tLastHelpRequest + HELP_REQUEST_INTERVAL < (gameTime / 10) ) or tLastHelpRequest == 0)
							{
							//if(!haveBeacon(me)
							_beacon = true;
							dropBeacon(getPlayerName(me), count, me, _targetX, _targetY, 0);
							}
						}
						count++;
					}

					if(_beacon)
					{
							tLastHelpRequest = gameTime / 10;
					}
				}
			}
		}	
	_count++;
	}
}

/////////////////////////////////////////////////////////////////////
// deal with attacks.
event droidDestroyed(droidDestroyedTr)
{

	local 		DROID 		_droid;

	if(droid.droidType == DROID_REPAIR or droid.droidType == DROID_CYBORG_REPAIR)
	{
		numRepairUnits = numRepairUnits - 1;
	}
	
	if(droid.droidType == DROID_SENSOR)
	{
		numSensorUnits = numSensorUnits - 1;
	}

	if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT)					// if constructor droid
	{
		initEnumStruct(FALSE,factory,me,me);
		structure= enumStruct();							// find factory.

		if( (structure != NULLOBJECT) and (getDroidCount(me) < MAX_DROIDS) )
		{
			buildDroid(constructor, structure, me, 1);	// build constructor
		}

	}
}


/////////////////////////////////////////////////////////////////////
// build more con droids.
event conDroids(conDroidsTr)
{
	local 	int			_maxTrucks,_count;
	local 	STRUCTURE	_factory;
	local	int 		_numBuilding,_haveTrucks,_maxTruckFactories,_totalTrucks;
	local	bool		_bStartedBuilding;

	numDerricks = countStruct(derrick) + countStruct(gderrick);
	
	if (gameTime > 2400)
	{
		_maxTrucks = ((numDerricks / 3) + 1);
	}
	else
	{
		_maxTrucks = MAX_TRUCKS;
	}

	if (playerPower(me) < MIN_PRODUCTIONPOWER_TRUCK)
	{
		_maxTrucks = MIN_TRUCKS;
	}

	_maxTruckFactories = 1; 		//max factories to use for truck production

	_haveTrucks = buildGroup.members;
	
	
	
	//Find out how many trucks and combat engineers are already in production
	_numBuilding = numTemplatesInProduction(constructor,me);	//trucks
	_numBuilding = _numBuilding + numTemplatesInProduction(cybEngineer,me);	//engineers

	_totalTrucks = _numBuilding + _haveTrucks;
	
	if(_totalTrucks > 4 and numRepairUnits < 1 and researchFinished(cybRepair, me) and gameTime > 3000)
	{
		setEventTrigger(repairDroids,chainloadTr);
		exit;
	}
	
	initEnumStruct(FALSE,factory,me,me);
	_factory = enumStruct();
	
	
	while ((_factory != NULLOBJECT) and (_numBuilding < _maxTruckFactories) and (_totalTrucks < _maxTrucks))
	{	
			//Try to build a truck
			if (skCanBuildTemplate(me, _factory, hovertruck))
			{
				_bStartedBuilding = buildUnit(hovertruck, _factory, factory, FALSE);	//build truck even if not idle
			}
			else
			{
				_bStartedBuilding = buildUnit(constructor, _factory, factory, FALSE);	//build truck even if not idle
			}
			
			//Update statistics if started building a truck
			if(_bStartedBuilding)
			{
				_numBuilding++;
				_totalTrucks++;
			}
		_factory = enumStruct();
	}
	
	//build cyborg engineers if needed
	initEnumStruct(FALSE,cybFactory,me,me);
	_factory = enumStruct();
	while((_factory != NULLOBJECT) and (_numBuilding < _maxTruckFactories) and (_totalTrucks < _maxTrucks))
	{
		//Try to build a truck
		if( skCanBuildTemplate(me,_factory, cybEngineer))	//make sure we have researched cyb engineer
		{
			_bStartedBuilding = buildUnit(cybEngineer, _factory, cybFactory, FALSE);	//build a cyb eng even if not idle
			
			//Update statistics if started building a cyborg engineer
			if(_bStartedBuilding)
			{
				_numBuilding++;
				_totalTrucks++;
			}
		}

		_factory = enumStruct();
	}
	
	if(_totalTrucks < _maxTrucks)
	{
		setEventTrigger(conDroids, conDroidsTr);
	}

}

//Build a droid
function bool buildUnit(TEMPLATE _tankTemplate, STRUCTURE _factory, STRUCTURESTAT _factoryType, bool _bIdleOnly)
{
	//Factory was not provided, find an factory
	if(_factory == NULLOBJECT)
	{
		_factory = findIdleStructure(_factoryType, _bIdleOnly);
	}

	//Build if got a factory
	if(_factory != NULLOBJECT)
	{
		if(structureComplete(_factory) and (getDroidCount(me) < MAX_DROIDS))
		{
			if( !(_bIdleOnly and !structureIdle(_factory)) )	//don't build if only allowed to build whe idle and fac is not idle
			{
				buildDroid(_tankTemplate, _factory, me, 1);	// build a tank
				return TRUE;	//success
			}
		}
	}

	return FALSE;		//failed
}

//Returns an idle structure of the provided type or NULLOBJECT if none found
function STRUCTURE findIdleStructure(STRUCTURESTAT _structType, bool _bIdleOnly)
{
	local	STRUCTURE	_structure;

	initEnumStruct(FALSE,_structType,me,me);
	_structure = enumStruct();
	while(_structure != NULLOBJECT)
	{
		if(structureComplete(_structure))
		{
			if( !(_bIdleOnly and !structureIdle(_structure)) )
			{
				return _structure;
			}
		}

		_structure = enumStruct();
	}
	
	return NULLOBJECT;	//none found
}

/////////////////////////////////////////////////////////////////////
// build repair droids.
event repairDroids(repairDroidsTr)
{
	local int _rnd;
	local bool _choseFactory;
	
	
	// if we're running low on repair droids, build some..
	if(numRepairUnits <7 and gameTime > 3000)
	{
		_choseFactory = false;
		_rnd = random(10);
		
		if(researchFinished(hover, me))
		{
			_rnd = 1;	
		}
		
		if(_rnd < 7)
		{
			initEnumStruct(FALSE,factory,me,me);
			structure= enumStruct();							// find factory.
			while(structure != NULLOBJECT and _choseFactory == false)
			{
				count = 5;
				while(count >= 0 )
				{
					if ((getDroidCount(me) < MAX_DROIDS) and (skCanBuildTemplate(me, structure, repair[count])) )
					{
						buildDroid(repair[count], structure, me, 1);	// build repairunit.
						count = -1;
						_choseFactory = true;
					}
					count = count - 1;
				}
				structure= enumStruct();
			}
		}
		else
		{
			initEnumStruct(FALSE,cybFactory,me,me);
			structure= enumStruct();							// find factory.
			while(structure != NULLOBJECT and _choseFactory == false)
			{
				count = 5;
				while(count >= 0 )
				{
					if ((getDroidCount(me) < MAX_DROIDS) and (skCanBuildTemplate(me, structure, repair[count])) )
					{
						buildDroid(repair[count], structure, me, 1);	// build repairunit.
						count = -1;
						_choseFactory = true;
					}
					count = count - 1;
				}
				structure= enumStruct();
			}
		}
		setEventTrigger(repairDroids,repairDroidsTr);
	}
}

/////////////////////////////////////////////////////////////////////
// build sensor droids.
event sensorDroids(sensorDroidsTr)
{

	if (!isStructureAvailable(facModule,me))
	{
	exit;
	}
	
	// if we're running low on sensor droids, build some..
	if(numSensorUnits < 3 and gameTime > 2400)
	{
		initEnumStruct(FALSE,factory,me,me);
		structure= enumStruct();							// find factory.
		if(structure != NULLOBJECT)
		{
			count = 7;
			while( count >= 0 )
			{
				if((getDroidCount(me) < MAX_DROIDS) and (skCanBuildTemplate(me, structure, sense[count])) )
				{
					count2 = 0;
					count2 = count - 1;
					if(random(10) <= 5 and count2 >= 0)
					{
						if(skCanBuildTemplate(me, structure, sense[count2]))
						{
							buildDroid(sense[count2], structure, me, 1);	// build sensorunit.
							count = -1;
						}
						else
						{
							buildDroid(sense[count], structure, me, 1);	// build sensorunit.
							count = -1;
						}
					}
					else
					{
						buildDroid(sense[count], structure, me, 1);	// build sensorunit.
						count = -1;
					}
				}
				
				count = count - 1;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
event factoryEvent(factoryEventTr)
{

	// for each factory....
	initEnumStruct(FALSE,factory,me,me);
	structure = enumStruct();								// find factory.
	if(getDroidCount(me) < MAX_DROIDS)
	{
		while(structure != NULLOBJECT and (playerPower(me) > MIN_PRODUCTIONPOWER_FACTORY))
		{
			if( structureIdle(structure) )
			{
				factoryBuildDroid(structure);
			}

			structure = enumStruct();
		}
	}
}

function bool needTank()
{
	if(not havePowerSource())
	{
		return FALSE;
	}
	
	if((defendGroup.members < maxDefenders[curTech]) or (maxDefenders[curTech] == UNLIMITED))
	{
		return TRUE;
	}

	if((attackGroup.members < maxAttackers[curTech]) or (maxAttackers[curTech] == UNLIMITED))
	{
		return TRUE;
	}

	return FALSE;
}

function void factoryBuildDroid(STRUCTURE _factory)
{
	local int _count,_count2,_maxTemplates;
	
	if(_factory == NULLOBJECT){
		dbg("factoryBuildDroid: factory is NULLOBJECT", me);
		return;
	}

	if(not needTank())
	{
		//dbg("NEED NO TANKS!! " & maxDefenders[curTech], me);
		return;
	}
	
	if(researchFinished(dragon, me))
	{
		_maxTemplates = 10;
	}
	else
	{
		_maxTemplates = MAX_RANDOM_TEMPLATES;
	}
	
	if( structureIdle(_factory) and (playerPower(me) > MIN_PRODUCTIONPOWER_FACTORY))
	{
		_count = numTemplates[curTech] - 1;
		_count2 = 0;
		if (gameTime < 6000)
		{
			while( (_count2 < 3) and (_count >= 0) )
			{
				if( skCanBuildTemplate(me,_factory, tmpl[curTech][_count]) )
				{
					tmplChoice[_count2] = tmpl[curTech][_count];
					_count2 = _count2 + 1;
				}
				_count = _count - 1;
			}
		}
		else
		{
			while( (_count2 < _maxTemplates) and (_count >= 0) )
			{
				if( skCanBuildTemplate(me,_factory, tmpl[curTech][_count]) )
				{
					tmplChoice[_count2] = tmpl[curTech][_count];
					_count2 = _count2 + 1;
				}
				_count = _count - 1;
			}
		}
	
		if(_count2 > 0)
		{
			buildDroid(tmplChoice[random(_count2)],_factory,me,1);
		}
	}
	else
	{
		dbg("factoryBuildDroid: factory is busy", me);
	}
}

/////////////////////////////////////////////////////////////////////
// put cyborg factories to work
event cyborgFactoryEvent(cyborgFactoryEventTr)
{

	if(not ((defendGroup.members < maxCyborgs[curTech]) or (maxCyborgs[curTech] == UNLIMITED)))
	{
		exit;		//we need no cyborgs
	}

	initEnumStruct(FALSE,cybFactory,me,me);
	structure= enumStruct();								// find factory.

	while(structure != NULLOBJECT)
	{
		if( structureIdle(structure) == TRUE and (playerPower(me) > MIN_PRODUCTIONPOWER_CYBFACTORY))
		{
			cybFactorBuildCyborg(structure);
		}
		structure= enumStruct();							// find factory.
	}
}

function void cybFactorBuildCyborg(STRUCTURE _factory)
{

	if(_factory == NULLOBJECT){
		dbg("cybFactorBuildCyborg: factory is NULLOBJECT", me);
		return;
	}
	
	if( structureIdle(_factory))
	{
		if( (defendGroup.members < maxCyborgs[curTech]) and (getDroidCount(me) < MAX_DROIDS) )
		{		
			count = 20;
			count2 = 0;
			while( count >= 0 )
			{
				if( skCanBuildTemplate(me,_factory, superCyb[count]) and count2 <=2 )
				{
					tmplChoice[count2] = superCyb[count];
					count2 = count2 + 1;
				}
				count = count - 1;
			}
			if(count2 > 0)
			{
				buildDroid(tmplChoice[random(count2)],_factory,me,1);
			}
			else	//try light cyborgs
			{
				count = numLightCyborgs - 1;
				count2 = 0;
				while( (count >= 0) and (count2 < 2) )
				{
					if( skCanBuildTemplate(me,_factory, cybTempl[count]) )
					{
						tmplChoice[count2] = cybTempl[count];
						count2++;
					}
					count--;
				}
				if(count2 > 0)
				{
					buildDroid(tmplChoice[random(count2)], _factory, me, 1);
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// process new visibility reports
event newObjectReport(newObjectReportTr)
{
	local STRUCTURE _derrick;
	local bool foundOne;
	
	if(!friendlyPlayer(baseobj.player))
	{
		if(targetTypeValue(baseobj) > targetTypeValue(attackObj))
		{
			attackObj = baseobj;// got a new unseen  target from a scout.

			if(	attackObj.type == OBJ_STRUCTURE)
			{
				if(not allianceExistsBetween(attackObj.player,me))	// an enemy
				{
					structure = objToStructure(attackObj);
					if(structure.stat == factory)
					{
						allOutAttack = attackObj;
					}
				}
			}
		}
	}
	
		if(isStructureAvailable(gTower, me))
		{
			_derrick = objToStructure(baseobj);
			
			if(_derrick != NULLOBJECT)
			{
				if(_derrick.stattype == REF_RESOURCE_EXTRACTOR)
				{
					foundOne = false;
					initIterateGroup(buildGroup);				
					droid = iterateGroup(buildGroup);
					while (droid != NULLOBJECT && !foundOne)
					{
						if(distBetweenTwoPoints(droid.x, droid.y, _derrick.x, _derrick.y) < (10 * TILE) and droidCanReach(droid, _derrick.x, _derrick.y))
						{
							orderDroidStatsLoc(droid, DORDER_BUILD, gTower, _derrick.x, _derrick.y);
							foundOne = true;
						}
						else
						{
							droid = iterateGroup(buildGroup);
						}
					}
				}
			}
		}
}

function int targetTypeValue(BASEOBJ _target)
{
	local STRUCTURE _strTarget;

	if(_target == NULLOBJECT){
		return NO_TARGET_VALUE;
	}

	if(_target.type == OBJ_DROID)
	{
		return DROID_TARGET_VALUE;
	}
	else if(_target.type == OBJ_STRUCTURE)
	{
		_strTarget = objToStructure(_target);

		if(_strTarget.stattype == REF_DEFENSE)
		{
			return DEFENSE_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_RESEARCH or
				_strTarget.stattype == REF_POWER_GEN)
		{
			return RESEARCH_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_HQ or
				_strTarget.stattype == REF_COMMAND_CONTROL)
		{
			return HQ_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_RESOURCE_EXTRACTOR)
		{
			return OIL_TARGET_VALUE;
		}
		else if(_strTarget.stattype == REF_FACTORY or
				_strTarget.stattype == REF_CYBORG_FACTORY or
				_strTarget.stattype == REF_VTOL_FACTORY)
		{
			return FACTORY_TARGET_VALUE;
		}
		else	//walls, rearm pads etc
		{
			return OTHER_TARGET_VALUE;
		}
	}

	return NO_TARGET_VALUE;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// spy technologies
//event takeover( CALL_UNITTAKEOVER , ref droid  )

event takeover(takeoverTr)
{
	if(droid.player == me)
	{
		if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT)
		{
			groupAddDroid(buildGroup, droid);
		}
		else if (droid.droidType != DROID_TRANSPORTER && droid.droidType != DROID_COMMAND)
		{
			groupAddDroid(attackGroup, droid);
		}
	}
}

event takeoverDefend(takeoverTr)
{
	if( droid.player != me )
	{
		completeResearch(nexusDefence,me);
		setEventTrigger(takeoverDefend,	inactive);
	}
}


event useLassat(useLassatTr)
{
	// find my lassat
	// fire it at my attack objective.
	if(allOutAttack != NULLOBJECT)
	{
		initEnumStruct(FALSE,lassat,me,me);
		structure= enumStruct();
		while(structure != NULLOBJECT)
		{
			if(structureComplete(structure) == TRUE)
			{
				skFireLassat(me,allOutAttack);
			}
			structure= enumStruct();
		}
	}
}

event remainingEnemy(remainingEnemyTr)
{
	local int _count;
	local	STRUCTURE		_structure;
	
	closestEnemy = nearestEnemy();
	closestAlly = nearestAlly();
	orderGroupLoc(attackGroup, DORDER_SCOUT, closestEnemyHQx, closestEnemyHQy);

}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// attack rules

event findEnemy(attackStuffTr)
{
	if(attackObj == NULLOBJECT)
	{
		count = random(8);
		count2 = 100;
		while( friendlyPlayer(count) && (count2 > 0) )
		{
			count = random(8);
			count2--;
		}

		if(!friendlyPlayer(count))
		{
			baseobj = skLocateEnemy(count);
			if(baseobj != NULLOBJECT)
			{
				attackObj =	baseobj;

				// set allOutAttack to attackObj only if attackObj is a more valuable target than allOutAttack
				if(targetTypeValue(attackObj) > targetTypeValue(allOutAttack))
				{
					allOutAttack = attackObj;
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
// send attack team out to cause trouble near things scout found.
event attackStuff(attackStuffTr)
{
	if( (attackObj != NULLOBJECT) and !haveBeacon(me))
	{
		if (not allianceExistsBetween(me, attackObj.player))
		{
			if(idleGroup(attackGroup) >= 6)
			{
				orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
			}
			else if(gameTime < 3300 and attackGroup.members > 0)
			{
				orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// defending rules

// defend attacked objects.
event defendWatch(defendWatchTr)
{
	if (baseobj != NULLOBJECT)
	{
		if(!friendlyPlayer(baseobj.player))
		{
			if(distBetweenTwoPoints(baseobj.x, baseobj.y, baseX, baseY) <= MAX_DEFENDERS_RADIUS)	//don't go too far away from the base
			{
				defendObj = baseobj;
				defendbusy = TRUE;
				// if not too busy, attack.
				if (idleGroup(defendGroup) >= (defendGroup.members / 2))
				{
					orderGroupLoc(defendGroup, DORDER_SCOUT,defendObj.x,defendObj.y);	//cyborg mechanics can't attack (won't move)
				}
			}
		}
	}
}

//returns number of non-idle structures of a certain type
function int numStructBusyByType(STRUCTURESTAT _busyStructType)
{
	local	int _result;

	initEnumStruct(FALSE,_busyStructType,me,me);
	structure = enumStruct();
	_result = 0;
	while(structure != NULLOBJECT)
	{
		if(structureComplete(structure))
		{
			if(not structureIdle(structure))
			{
				_result++;
			}
		}
		structure = enumStruct();
	}

	return _result;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Research Rules Now does true research.
// do research

event doResearch(doResearchTr)
{
	local	int		_techIndex,_numResearching,_oilCount,_playerCount;
	local FEATURE	_oil;
	
	// don't throw in half of your money on research in T3 no bases when we don't have any income yet
	if (isStructureAvailable(facModule,me) and numDerricks < 4 and gameTime < 3000)
	{
		setEventTrigger(doResearch, delayedloadTr);
		exit;
	}
	
	// After 20 minutes lets put any spare research centers we're not using to work. Otherwise only pursue the research items defined in the research objectives.
	if(gameTime > 12000)
	{
		maxIdleRes[curTech] = -1;
	}
	
	_techIndex = 0;	//research start
	_numResearching = numStructBusyByType(resLab);

	// for every research lab do this..
	initEnumStruct(FALSE,resLab,me,me);
	structure= enumStruct();
	count = 0;
	while(structure != NULLOBJECT)
	{
		boolResult = FALSE;		//haven't started research for the current resFac

		if(structureIdle(structure))
		{
			if(structureComplete(structure))
			{
				// first research all technologies necessary for the current research branch
				while(not boolResult and _techIndex != NONE)	//not started researching and still branch tech left to try
				{
					_techIndex = findResearch(_techIndex, curTech);
					if(_techIndex > NONE)
					{
						boolResult = pursueResearch(structure,me,tech[curTech][_techIndex]);

						_techIndex++;	//try nect research next time if needed
						_numResearching++;
					}
				}

				// do common research
				if(not boolResult)	//didn't start branch research
				{
					if((maxIdleRes[curTech] == UNLIMITED) or (_numResearching < maxIdleRes[curTech]))
					{
						skDoResearch(structure,me,0);
						_numResearching++;
					}
				}
			}
		}

		structure = enumStruct();
	}
	setEventTrigger(doResearch, doResearchTr);
}

// find next available research of our research branch
function int findResearch(int _searchStart, int _techTree)
{
	local	int	_result;

	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me);
	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me);

	_result = _searchStart;
	while(_result < techCount[_techTree])
	{
		if((not researchFinished(tech[_techTree][_result], me)) and (not researchStarted(tech[_techTree][_result], me)))
		{
			return _result;		//found research
		}
		_result++;
	}

	return NONE;		//not found
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// Alliance Rules

// form alliances
event formAllianceEvent(formAllianceEventTr)
{
	count = 0;
	while(count < MAX_PLAYERS)
	{
		if( count != me )												// if not the only other player and rand2
		{
			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
			{
				if(random(28) == 1)											// bit random
				{
					if(not isHumanPlayer(count))							// not human
					{
						createAlliance(me,count);
						allianceTime[count] = gameTime;
					}
				}
			}
		}
		count = count + 1;
	}
}

/////////////////////////////////////////////////////////////////////
// break the alliance too.
event breakAllianceEvent(breakAllianceEventTr)
{
	count = 0;
	while(count<multiPlayerMaxPlayers)
	{
		if( count != me)
		{
			if((getDroidCount(me) > 1) and (getDroidCount(count) > 1) )	// not dead
			{
				if(allianceExistsBetween(me,count) )
				{
					// check if we're in alliance with any other players.
					if( (random(30) == 1) and ( (gameTime - allianceTime[count]) > 6000) )	// rand and more than 10 minutes.
					{
						allianceTime[count] = gameTime;
						breakAlliance(me,count);
					}

					// rules for breaking alliances with humans.
					// built within my base
					if(numStructsInArea(count,minx,miny,maxx,maxy) > 1)
					{
						allianceTime[count] = gameTime;
						breakAlliance(me,count);
					}

					// you've got lots of units in my area.
					if(numDroidsInArea(count,minx,miny,maxx,maxy) > 3)
					{
						allianceTime[count] = gameTime;
						breakAlliance(me,count);
					}

					// you've wiped out one of my allies ??.
				}
			}
		}
		count = count + 1;
	}
}

/////////////////////////////////////////////////////////////////////
event formHumanAlliances(humanAllianceTr)
{
	if(count2 == me) // offered to me.
	{
		result = 0;
		result2 = 0;
		while(result < multiPlayerMaxPlayers)
		{
			if(allianceExistsBetween(count,result))
			{
				result2 = result2 + 1;
			}
			result = result + 1;
		}
		if( result2 < ((multiPlayerMaxPlayers / 2) - 1) )	// not too many already
		{
			//not too soon.
			if((allianceTime[count] == 0) or (gameTime - allianceTime[count] > 1200))
			{
				result = 0;								// check forming wont end the game
				result2 = 0;
				while(result < multiPlayerMaxPlayers)
				{
					while(result2 < multiPlayerMaxPlayers)
					{
						if((not allianceExistsBetween(result,result2)) and (getDroidCount(result) > 0) and (getDroidCount(result2) > 0) and (result != result2) )
						{
							if( ((result == count and result2 == count2) or (result2 == count2 and result == count)) )	// ignore the outcome of this alliance
							{
								createAlliance(me,count);
								allianceTime[count] = gameTime;
							}
						}
						result2 = result2 + 1;
					}
					result = result + 1;
				}
			}

		}
	}
}

/////////////////////////////////////////////////////////////////////
// vtols.
/////////////////////////////////////////////////////////////////////
// build vtol strucutures.
event vtolStructs(inactive)
{
	local	int		_numVtolFacs,_numRearmPads;

	
	if (isStructureAvailable(facModule,me) and not havePowerSource() and numDerricks < 3 and gameTime < 3000)
	{
		setEventTrigger(vtolStructs, vtolStructsTr);
		exit;
	}
	
	// got any idle trucks?
	if (idleGroup(buildGroup) < 3)
	{
		exit;
	}

	// see how many vtol factories we already have
	_numVtolFacs = getNumStructures(vtolFactory,me);
	_numRearmPads = getNumStructures(vtolPad,me);

	//see if we have enough rearm pads
	
	if(curTech == branchFlamer)
	{
		if( _numRearmPads <= totalVtols())
		{
			dbg("NEED REARM PADS", me);
			buildRearmPads();
		}
	}
	else
	{
		if( _numRearmPads * 4 / 3 <= totalVtols())
		{
			dbg("NEED REARM PADS", me);
			buildRearmPads();
		}

		if (_numVtolFacs > 0 and playerPower(me) < MIN_BUILDPOWER_VTOLFACTORY)
		{
			exit;	// Throttle expansion to avoid waste
		}
	}
	
	if (isStructureAvailable(vtolFactory, me) and _numVtolFacs < maxVtolFacs[curTech])			// if not enough
	{
		if (not grabTrucksAndBuild(6, vtolFactory, 1))
		{
			dbg("Failed to build Vtol fac", me);
		}
	}
	
	
}

function int countStruct(STRUCTURESTAT _structure)
{
	initEnumStruct(FALSE,_structure,me,me);					// count = numderricks
	structure= enumStruct();
	count = 0;
	while(structure != NULLOBJECT)
	{
		count = count + 1;
		structure= enumStruct();
	}

	return count;
}
		

//counts vtols
function int totalVtols()
{
	local	int		_totalVtols;

	_totalVtols = 0;
	InitEnumDroids(me,me);
	droid = EnumDroid();
	while (droid != NULLOBJECT)
	{
		if(isVtol(droid))
		{
			_totalVtols++;
		}
		droid = EnumDroid();
	}
	return _totalVtols;
}

function void buildRearmPads()
{
	if (isStructureAvailable(vtolPad, me))
	{
		if (not grabTrucksAndBuild(0, vtolPad, -1))
		{
			dbg("Failed to build vtol pad", me);
		}
	}
}

function void buildAA()
{
	local	int		_count;
	
	_count = 8;
	while( _count > 0)
	{
		if(isStructureAvailable(vtolDefStruct[count],me))
		{
			if (not grabTrucksAndBuild(10, vtolDefStruct[count], -1))
			{
				dbg("Failed to build AA defense", me);
			}
		}
		_count = _count - 1;
	}
}


/////////////////////////////////////////////////////////////////////
// build vtols.

event buildVtols(inactive)
{
	// got enough vtols?
	if((totalVtols() >= maxVTOLs[curTech]) or (getDroidCount(me) >= MAX_DROIDS)){
		dbg("CAN'T BUILD VTOLS - TOO MANY UNITS", me);
		exit;
	}
	// build vtols
	initEnumStruct(FALSE,vtolFactory,me,me);
	structure = enumStruct();
	
	if(curTech == branchFlamer)
	{
		while(structure != NULLOBJECT)
		{
			if(structureIdle(structure))	// if factory idle
			{
				vtolFactoryBuildVtol(structure);
			}
		structure = enumStruct();
		}
	}
	else
	{
		while(structure != NULLOBJECT)
		{
			if(structureIdle(structure))	// if factory idle
			{
				vtolFactoryBuildVtol(structure);
			}
		structure = enumStruct();
		}
	}
}


function void vtolFactoryBuildVtol(STRUCTURE _factory)
{
	local	int		_numTemplates,_bestTemplates,_randomTemplates;

	if(_factory == NULLOBJECT){
		return;
	}

	if( structureIdle(_factory) )
	{
		_numTemplates = numVtolTemplates - 1;
		_bestTemplates = 0;
		
		if(researchFinished(retribution, me))
		{
			_randomTemplates = 6;
		}
		else
		{
			_randomTemplates = 2;	
		}
			
		while( (_bestTemplates < 3) and (_numTemplates >= 0) )
		{
			if( skCanBuildTemplate(me,_factory, vtols[_numTemplates]) )
			{
				tmplChoice[_bestTemplates] = vtols[_numTemplates];
				_bestTemplates++;
			}
			_numTemplates--;
		}

		if(_bestTemplates > 0)
		{
			buildDroid(tmplChoice[random(_bestTemplates)],_factory,me,1);
		}
	}
}


function int nearestEnemy()
{
		local		int			_enemy,_closestEnemy,_newDist,_bestDist,_closestEnemyX,_closestEnemyY;
		local		bool		_haveTruck;
		_bestDist = 99999;
		_closestEnemy = -1;
		_enemy = 0;
		while(_enemy < 10)
		{
			if(!allianceExistsBetween(me, _enemy))
			{
				initEnumStruct(FALSE,playerHQ,_enemy,_enemy);					
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					_newDist = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y);
	
					if (_newDist < _bestDist)	
					{
						_bestDist = _newDist;
						_closestEnemy = structure.player;
						_closestEnemyX = structure.x;
						_closestEnemyY = structure.y;
					}
					structure= enumStruct();
				}
				
				if(getStructure(playerHQ, _enemy) == NULLOBJECT)
				{	
					_haveTruck = FALSE;
					InitEnumDroids(_enemy,_enemy);
					droid = EnumDroid();
					while (droid != NULLOBJECT and _haveTruck == FALSE)
					{
						if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT) // check to see if any of our allies don't have a truck
						{
							_haveTruck = TRUE;
							_newDist = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y);
							
							if (_newDist < _bestDist)	
							{
								_bestDist = _newDist;
								_closestEnemy = droid.player;
								_closestEnemyX = droid.x;
								_closestEnemyY = droid.y;
							}
						}
						droid = EnumDroid();
					}
				}
						
			}
			_enemy++;
		}
	closestEnemy = _closestEnemy;
	closestEnemyDist = _bestDist;
	closestEnemyHQx = _closestEnemyX;
	closestEnemyHQy = _closestEnemyY;	
	return _closestEnemy;
}


event vtolAttack(inactive)
{
	local		int			_enemy,_bestDist,_newDist,_count,_rnd,_targetX,_targetY,_numDefendVTOL,_numEnemyFacts,_numEnemyCybFacts,_numEnemyTrucks,_closestEnemy,_lzx,_lzy;
	local		BASEOBJ		_newTarget;
	local		bool		_bHaveDefendTarget;
	local		DROID		_droid,_enemyTrucks[15],_transporter;
	local		STRUCTURE	_target,_enemyFacts[5],_enemyCybFacts[5];

	_numDefendVTOL = 0;
	InitEnumDroids(me,me);
	droid = EnumDroid();
	while (droid != NULLOBJECT)
	{
		if(droid.droidType == DROID_TRANSPORTER)
		{
			_transporter = droid;
		}
		if(isVtol(droid))
		{
			if(droid.order == DORDER_NONE)
			{
				orderDroid(droid, DORDER_RTR);
			}
			if(droid.action != DACTION_MOVETOREARMPOINT and droid.order != DORDER_ATTACK and droid.action != DACTION_WAITFORREARM and droid.action != DACTION_MOVETOREARM and droid.action != DACTION_WAITDURINGREARM)
			{
				if(droid.weapon == empBomb)
				{
					_numDefendVTOL++;
					groupAddDroid(vtolDefendGr, droid);
				}
				else if(distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < (25 * TILE) and _numDefendVTOL < 15)
				{
					_numDefendVTOL++;
					groupAddDroid(vtolDefendGr, droid);
				}
				else
				{
					groupAddDroid(vtolAttackGr, droid);
				}
			}
		}
		droid = EnumDroid();
	}
	

	
	if(vtolAttackGr.members > 10)
	{
				_closestEnemy = nearestEnemy();

				_numEnemyFacts = 0;
				initEnumStruct(FALSE,factory,_closestEnemy,_closestEnemy);					
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					_enemyFacts[_numEnemyFacts] = structure;
					_numEnemyFacts++;
					structure= enumStruct();
				}
				
				_numEnemyTrucks = 0;
				InitEnumDroids(_closestEnemy,_closestEnemy);
				droid = EnumDroid();
				while (droid != NULLOBJECT)
				{
					if(droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT)
					{	
						_enemyTrucks[_numEnemyTrucks] = droid;
						_numEnemyTrucks++;
					}
					droid = EnumDroid();
				}
				
				_numEnemyCybFacts = 0;
				initEnumStruct(FALSE,cybFactory,_closestEnemy,_closestEnemy);					
				structure= enumStruct();
				while(structure != NULLOBJECT)
				{
					_enemyCybFacts[_numEnemyCybFacts] = structure;
					_numEnemyCybFacts++;
					structure= enumStruct();
				}
				
		_rnd = random(10);
		if(_numEnemyTrucks > 0 and _rnd >= 5)
		{
			count = 0;
			initIterateGroup(vtolAttackGr);
			droid = iterateGroup(vtolAttackGr);
			while(droid != NULLOBJECT)
			{	
				if(droid.action != DACTION_MOVETOREARMPOINT or droid.order != DORDER_ATTACK and droid.action != DACTION_WAITFORREARM and droid.action != DACTION_MOVETOREARM and droid.action != DACTION_WAITDURINGREARM)
				{
					if(count < _numEnemyTrucks)
					{
						if(_enemyTrucks[count] != NULLOBJECT)
						{
							orderDroidObj(droid, DORDER_ATTACK, _enemyTrucks[count]);
							count++;
						}
						
					}
				}
				droid = iterateGroup(vtolAttackGr);	
			}
		}
		else if(_numEnemyFacts > 0)
		{
			_target = _enemyFacts[random(_numEnemyFacts)];
			if(_target != NULLOBJECT)
			{
				initIterateGroup(vtolAttackGr);
				droid = iterateGroup(vtolAttackGr);
				while(droid != NULLOBJECT)
				{	
						if(droid.action == DACTION_MOVETOREARMPOINT or droid.action == DACTION_WAITFORREARM or droid.action == DACTION_MOVETOREARM or droid.action == DACTION_WAITDURINGREARM)
						{
							droidLeaveGroup(droid);
						}
					droid = iterateGroup(vtolAttackGr);	
				}
				orderGroupObj(vtolAttackGr, DORDER_ATTACK,_target);
			}
		}
		else
		{
			_target = _enemyCybFacts[random(_numEnemyCybFacts)];
			if(_target != NULLOBJECT)
			{
				initIterateGroup(vtolAttackGr);
				droid = iterateGroup(vtolAttackGr);
				while(droid != NULLOBJECT)
				{	
						if(droid.action == DACTION_MOVETOREARMPOINT or droid.action == DACTION_WAITFORREARM or droid.action == DACTION_MOVETOREARM or droid.action == DACTION_WAITDURINGREARM)
						{
							droidLeaveGroup(droid);
						}
					droid = iterateGroup(vtolAttackGr);	
				}
				orderGroupObj(vtolAttackGr, DORDER_ATTACK,_target);
			}
		}
	}
//	
//	if(_transporter != NULLOBJECT)
//	{
//		
//		//if(distBetweenTwoPoints(_transporter.x,_transporter.x,baseX,baseY) <= (15 * TILE)))
//			
//		
//		_closestEnemy = nearestEnemy();
//		
//		if(getStructure(playerHQ, _closestEnemy) != NULLOBJECT)
//		{
//			initEnumStruct(FALSE,playerHQ,_closestEnemy,_closestEnemy);					
//			structure= enumStruct();
//			while(structure != NULLOBJECT)
//			{
//				_lzx = structure.x;
//				_lzy = structure.y;
//				structure= enumStruct();
//			}
//		}
//		
//		if(numEnemyAAInRange(_lzx, _lzy, (16 * TILE)) < 3)
//		{
//			InitEnumDroids(me,me);
//			droid = EnumDroid();
//			while (droid != NULLOBJECT)
//			{
//				if(droid.droidType == DROID_CYBORG and distBetweenTwoPoints(droid.x,droid.x,baseX,baseY) <= (15 * TILE) and transportGroup.members < 6)
//				{
//					orderDroid(droid, DORDER_EMBARK);
//					groupAddDroid(transportGroup, droid);
//				}
//				droid = EnumDroid();
//			}	
//		}	
//		
//		if(transportGroup.members > 2)
//		{
//			orderDroidLoc(_transporter, DORDER_MOVE,_lzx, _lzy);
//		}
//	}
	
}


function int numEnemyAAInRange(int _x, int _y, int _range)
{
	local int _enemy,_numAA;

	_numAA = 0;
	_enemy = 0;
	while(_enemy < MAX_PLAYERS)
	{
		if(!friendlyPlayer(_enemy))
		{
			_numAA = _numAA + numAAinRange(_enemy, me, _x, _y, _range);
		}
		_enemy++;
	}

	return _numAA;
}



/////////////////////////////////////////////////////////////////////
// watch for incoming vtols
event vtolDefend(vtolDefendTr)
{
	local	int		_numBuilders,_maxBuilders;

	if(baseobj != NULLOBJECT)
	{
		if(baseobj.type == OBJ_DROID)
		{
			if(isVtol(objToDroid(baseobj)))
			{
				_numBuilders = 0;
				_maxBuilders = 2;

				// build defenses.
				initIterateGroup(buildGroup);		// find idle droids in build group.
				droid = iterateGroup(buildGroup);
				while( droid != NULLOBJECT)
				{
					if(structure != NULLOBJECT)
					{
						buildX = structure.x;
						buildY = structure.y;
						//	if ! vtol defense already built...

						//find best defense we can build.
						count = 0;
						count2 = -1;
						while( count < 9)
						{
							if(isStructureAvailable(vtolDefStruct[count],me))
							{
								count2 = count;
							}
							count = count + 1;
						}
						if(count2 != (-1) )
						{
							boolResult = pickDroidStructLocation(droid, vtolDefStruct[count2], ref buildX, ref buildY, me, 1);
							if (boolResult == TRUE and (_numBuilders < _maxBuilders))	// build a vtol defense near the attacked struct...
							{							
								
								
//								initEnumStruct(FALSE,vtolFactory,me,me);			
//								structure = enumStruct();
//								if(skCanBuildTemplate(me,structure, vtolAAdroid))
//								{
//									while(structure != NULLOBJECT)			
//									{			
//										buildDroid(vtolAAdroid,structure,me,1);		
//									structure = enumStruct();			
//									}
//								}
								orderDroidStatsLoc(droid, DORDER_BUILD,vtolDefStruct[count2],buildX,buildY);
								_numBuilders++;
							}
						}

					}
					droid = iterateGroup(buildGroup);
				}
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
event vtolEnabler(vtolEnablerTr)
{
	if( skVtolEnableCheck(me) )					// check to see if we have vtol technologies.
	{
		setEventTrigger(vtolEnabler,inactive);		// turn off this event.
		setEventTrigger(vtolStructs,vtolStructsTr);	// activate other vtol functions..
		setEventTrigger(buildVtols,	buildVtolsTr);
		setEventTrigger(vtolAttack,	vtolAttackTr);
		dbg("----I CAN USE VTOLS----", me);
	}
	
//	if(!researchFinished(transporter, me))
//	{
//		initEnumStruct(FALSE,resLab,me,me);	
//		structure= enumStruct();
//		while(structure != NULLOBJECT)
//		{
//			pursueResearch(structure, me, transporter);
//			structure= enumStruct();
//			structure = NULLOBJECT;
//		}
//	}
}

/////////////////////////////////////////////////////////////////////
// HouseKeeping

function void shutDownAI()
{
	bRunning = false;

	setEventTrigger(basedetails,	inactive);
	setEventTrigger(droidOrders,	inactive);
	setEventTrigger(repairBase,	inactive);
	setEventTrigger(repairGrp,	inactive);
	setEventTrigger(checkOnAlly,	inactive);
	setEventTrigger(buildDerrick,	inactive);
	setEventTrigger(buildOilDefenseOrRetreat,	inactive);
	setEventTrigger(incendry,	inactive);
	setEventTrigger(buildPowerGenerators,	inactive);
	setEventTrigger(buildFactory,	inactive);
	setEventTrigger(buildBase,	inactive);
	setEventTrigger(upgradeStructures,inactive);
	setEventTrigger(finishStructs,	inactive);
	setEventTrigger(newfortify,	inactive);
	setEventTrigger(droidBuiltAssign, inactive);
	setEventTrigger(droidBuilt,	inactive);
	setEventTrigger(structBuilt,inactive);
	setEventTrigger(droidDestroyed,inactive);
	setEventTrigger(conDroids,inactive);
	setEventTrigger(repairDroids,inactive);
	setEventTrigger(sensorDroids,inactive);
	setEventTrigger(factoryEvent,	inactive);
	setEventTrigger(cyborgFactoryEvent,	inactive);
	setEventTrigger(newObjectReport,	inactive);
	setEventTrigger(takeover,	inactive);
	setEventTrigger(takeoverDefend,	inactive);
	setEventTrigger(useLassat,	inactive);
	setEventTrigger(findEnemy,	inactive);
	setEventTrigger(attackStuff,	inactive);
	setEventTrigger(defendWatch,	inactive);
	setEventTrigger(doResearch,	inactive);
	setEventTrigger(formAllianceEvent,	inactive);
	setEventTrigger(breakAllianceEvent,	inactive);
	setEventTrigger(formHumanAlliances,	inactive);
	setEventTrigger(vtolStructs,inactive);
	setEventTrigger(buildVtols,inactive);
	setEventTrigger(vtolAttack,inactive);
	setEventTrigger(vtolDefend,inactive);
	setEventTrigger(vtolEnabler,inactive);
	setEventTrigger(beaconEv,	inactive);
	setEventTrigger(multiMsgEv,	inactive);
	setEventTrigger(manageAllyHelp,	inactive);
	setEventTrigger(everySecEv,	inactive);
	setEventTrigger(watchBaseThreat, inactive);
	setEventTrigger(manageDefendLocationEv,	inactive);
	setEventTrigger(structureDestroyed,inactive);
	setEventTrigger(rebuildStructureEv,inactive);
	setEventTrigger(startLevel, inactive);
//	setEventTrigger(arrived, inactive);
	setEventTrigger(checkResearch, inactive);
//	setEventTrigger(announceResearch,	inactive);
	setEventTrigger(spendPower,	inactive);
}

function void reassignAI()
{
	bRunning = true;

	setEventTrigger(basedetails,basedetailsTr);
	setEventTrigger(droidOrders,droidOrdersTr);
	setEventTrigger(repairBase,repairBaseTr);
	setEventTrigger(repairGrp,repairGrpTr);
	setEventTrigger(checkOnAlly,checkOnAllyTr);
	setEventTrigger(buildDerrick,buildDerrickTr);
	setEventTrigger(buildOilDefenseOrRetreat,buildOilDefenseOrRetreatTr);
	setEventTrigger(incendry,incendryTr);
	setEventTrigger(spendPower,spendPowerTr);
	setEventTrigger(buildPowerGenerators,buildPowerGeneratorsTr);
	setEventTrigger(buildReCenters,buildReCentersTr);
	setEventTrigger(buildFactory,buildFactoryTr);
	setEventTrigger(buildCyFactory,buildCyFactoryTr);
	setEventTrigger(buildVTOLFactory,buildVTOLFactoryTr);
	setEventTrigger(buildBase,buildBaseTr );
	setEventTrigger(upgradeStructures,upgradeStructuresTr );
	setEventTrigger(finishStructs,finishStructsTr );
	setEventTrigger(newfortify,fortifyTr );
	setEventTrigger(droidBuiltAssign,droidBuiltTr);
	setEventTrigger(droidBuilt,droidBuiltTr);
	setEventTrigger(droidDestroyed,droidDestroyedTr);
	setEventTrigger(enemyNearBase,enemyNearBaseTr);
	setEventTrigger(conDroids,conDroidsTr);
	setEventTrigger(repairDroids,repairDroidsTr);
	setEventTrigger(sensorDroids,sensorDroidsTr);
	setEventTrigger(factoryEvent,factoryEventTr);
	setEventTrigger(cyborgFactoryEvent,cyborgFactoryEventTr);
	setEventTrigger(newObjectReport,newObjectReportTr);
	setEventTrigger(takeover,takeoverTr);
	setEventTrigger(useLassat,useLassatTr);
	setEventTrigger(findEnemy,attackStuffTr);
	setEventTrigger(remainingEnemy,remainingEnemyTr);
	setEventTrigger(attackStuff,attackStuffTr);
	setEventTrigger(defendWatch,defendWatchTr);
	setEventTrigger(doResearch,doResearchTr);
	setEventTrigger(formAllianceEvent,formAllianceEventTr);
	setEventTrigger(breakAllianceEvent,breakAllianceEventTr);
	setEventTrigger(vtolStructs,inactive);
	setEventTrigger(buildVtols,inactive);
	setEventTrigger(vtolAttack,inactive);
	//setEventTrigger(vtolAttack,	vtolAttackTr);
	setEventTrigger(vtolDefend,vtolDefendTr);
	setEventTrigger(vtolEnabler,vtolEnablerTr);
	setEventTrigger(formHumanAlliances,humanAllianceTr);
	setEventTrigger(multiMsgEv, multiMsgTr);
	setEventTrigger(beaconEv, beaconTr);
	setEventTrigger(watchBaseThreat, watchBaseThreatTr);
	setEventTrigger(manageAllyHelp, manageAllyHelpTr);
	setEventTrigger(everySecEv, everySec);
	//setEventTrigger(manageDefendLocationEv, manageDefendLocationTr);
	setEventTrigger(structBuilt, structBuiltTr);
	setEventTrigger(structureDestroyed, structureDestroyedTr);
	setEventTrigger(rebuildStructureEv, rebuildStructureTr);
	setEventTrigger(startLevel, startLevelTr);
	setEventTrigger(arrived, reachedTr);
	setEventTrigger(checkResearch, checkResearchTr);
}

/* Returns true if we just received a beacon from a certain player */
function bool haveBeacon(int _player)
{
		if((tBeacon[_player] > 0) and (not beaconTimeout(_player)))
		{
			return TRUE;	//have beacon for this player
		}

		return FALSE;
}

/* See if last beacon was placed long ago */
function bool beaconTimeout(int _player)
{
	if((tBeacon[_player] > 0) and
		((tBeacon[_player] + BEACON_TIMEOUT) < (gameTime / 10)))	//not too long ago
	{
		return TRUE;	//this beacon is still 'fresh'
	}

	return FALSE;
}

/* Deal with beacons */
event beaconEv(beaconTr)
{
	local	int			_players;
	local	string		_processedString;

	if(_DEBUG)
		debug(me & ") beaconEv: from " & sender);

	ASSERT(sender >= 0 and sender < MAX_PLAYERS,
		"beaconEv: sender out of bounds: " & sender , me);

	beaconX[sender] = x;
	beaconY[sender] = y;
	tBeacon[sender] = gameTime / 10;

	processCommand(message, sender, TRUE);
	
	if(allianceExistsBetween(me, sender))
	{
		orderGroupLoc(attackGroup, DORDER_SCOUT, beaconX[sender], beaconY[sender]);
	}

}

/* Deal with a chat message */
event multiMsgEv(multiMsgTr)
{
	if(_DEBUG)
		debug(me & ") multiMsgEv: from " & sender);

	if(not allianceExistsBetween(me, sender)){
		exit;
	}

	if(sender == me){
		exit;
	}

	processCommand(message, sender, FALSE);
}

/* Process multiplayer messages */
function void processCommand(string _message, int _sender, bool _bBlipMessage)
{
	local	int 		_numMsgs,_curMsg,_addressedPlayers,_x,_y;
	local	string		_msg,_processedString;

	/* Extract semantic information */
	_curMsg = 0;
	_numMsgs = processChatMsg(_message);

	debug(me & ") processCommand: '" & _message & "' from " & _sender);
	dbg("processCommand: '" & _message & "' from " & _sender, me);
	dbg("got " & _numMsgs & " commands", me);

	/* Process all messages */
	while(_curMsg < _numMsgs)
	{
		if(chatCmdIsPlayerAddressed(_curMsg, me))
		{
			dbg("i'm addressed", me);
			_msg = getChatCmdDescription(_curMsg);

			/* Someone requested help */
			if(_msg == R_REQUEST_HELP)
			{
				dbg("'help' command", me);

				if(haveBeacon(_sender))
				{
					dbg("got beacon", me);

					_x = beaconX[_sender];
					_y = beaconY[_sender];

					if(attemptToHelp(_sender, _x, _y))
					{
						messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
					}
				}
				else
				{
					/* Ask player to drop a beacon so we would know where to help */
					_addressedPlayers = setBit(0, _sender, TRUE);
					messagePlayerAddressed(ALL_ALLIES, _addressedPlayers, R_REQUEST_BEACON);
				}
			}
			/* Someone requested a beacon from us -
			 * did we request help and our beacon timed out??
			 */
			else if(_msg == M_REQUEST_BEACON)
			{
				/* If our base is really in trouble drop a beacon for the requester again */
				if(baseInTrouble()){
					dropBeacon(getPlayerName(me), _sender, me, baseX, baseY, 0);
				}
			}
			else if(_msg == R_REPORT_SAFETY)
			{
				dbg("helping " & lastHelpPlayer, me);

				/* Make sure we were helping him */
				if(helpingAlly() and (lastHelpPlayer == _sender))
				{
					stopHelpingAlly();
					messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY);
				}
				else if(defendingOwnBase())	//if we are in trouble re-request help
				{
					requestHelp(baseX, baseY);
				}
			}
			else
			{
				dbg("unknown message", me);
			}

		}
		else
		{
			dbg("i'm not addressed", me);
		}

		_curMsg++;
	}
}

function bool attemptToHelp(int _playerToHelp, int _x, int _y)
{
	local bool _bHelpingMyself;

	if(_playerToHelp < 0 or _playerToHelp >= MAX_PLAYERS){
		return FALSE;
	}

	if(_x <= 0 or _y <= 0){
		return FALSE;
	}

	dbg("attemptToHelp - checking", me);

	_bHelpingMyself = (_playerToHelp == me);

	/* Can only help allies and myself */
	if(not friendlyPlayer(_playerToHelp)){
		return FALSE;
	}

	if(_bHelpingMyself or !helpingAlly() or (lastHelpPlayer == _playerToHelp) )	//if not helping any other ally or it's me who needs help
	{
		dbg("not busy helping", me);

		if(haveHelpers() or _DEBUG)
		{
			dbg("got attackers", me);
			if(allyBaseAtLoc(_playerToHelp, _x, _y))	//is he just trying to misuse us?
			{
				helpPlayer(_playerToHelp, _x, _y);
				return TRUE;
			}
			else
			{
				dbg("ally needs no help", me);
				messagePlayer(ALL_ALLIES, M_ANNOYED, MAX_PROBABILITY / 2);
			}
		}
		else
		{
			messagePlayer(ALL_ALLIES, M_HELP_NO_UNITS, MAX_PROBABILITY);
		}
	}
	else if((lastHelpPlayer >= 0) and (lastHelpPlayer < MAX_PLAYERS))
	{
		if(!_bHelpingMyself){
			messagePlayer(ALL_ALLIES, "helping " & getPlayerName(lastHelpPlayer) & " already", MAX_PROBABILITY);
		}
	}

	return FALSE;
}

/* Start helping player */
function void helpPlayer(int _playerToHelp, int _helpX, int _helpY)
{
	local int _tTravelTime;

	dbg("helping " & _playerToHelp, me);

	if(_DEBUG)
		debug(me & ") helpPlayer: '" & _playerToHelp);

	//Calculate travel time, assume ~ 150 tiles in 4 minutes
	if(attackGroup.members == 0){
		_tTravelTime = (int)((float)(distBetweenTwoPoints(baseX, baseY, _helpX, _helpY) / 128 ) * 1.7);
	}else{
		_tTravelTime = (int)((float)(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _helpX, _helpY) / 128 ) * 1.7);
	}

	tHelp = gameTime / 10;
	tHelpTimeout = (gameTime / 10) + BASE_DEFEND_DURATION + _tTravelTime;
	lastHelpPlayer = _playerToHelp;
	helpX = _helpX;
	helpY = _helpY;

	/* Scouts and attackers go to help */
	defendLocation(_helpX, _helpY, tHelpTimeout, (_playerToHelp == me));
}

/* Returns a random affirmative responce */
function string m_affirmative()
{
	local int _rnd;

	_rnd = random(4);
	if(_rnd == 3)
	{
		return M_AFFIRMATIVE_ROGER;
	}

	return M_AFFIRMATIVE_OK;
}

/* See if there are any base structures belonging to ally at a certain location */
function bool allyBaseAtLoc(int _ally, int _x, int _y)
{
	local int _structIndex;

	if(_x <= 0 or _y <= 0){
		return FALSE;
	}

	if(_ally < 0 or _ally >= MAX_PLAYERS){
		return FALSE;
	}

	_structIndex = 0;
	while(_structIndex < numBaseStruct)
	{
		if(numStructsByStatInRange(baseStruct[_structIndex], _x, _y, (7 * 128), me, _ally) > 0 )
		{
			return TRUE;
		}

		_structIndex++;
	}

	return FALSE;
}

event manageAllyHelp(manageAllyHelpTr)
{
	if(helpingAlly())
	{
		if(canStopHelpingAlly())
		{
			stopHelpingAlly();
		}
	}
}

event everySecEv(everySec)
{
	/* Check if we were helping long enough */
	if(helpingAlly())
	{
		if(helpAllyTimeout())
		{
			stopHelpingAlly();
		}
	}

	if(defendingLocation())
	{
		if(defendLocationTimeout())
		{
			stopDefendingLocation();
		}
	}
}

/* Do we have any units we can send to help ally ? */
function bool haveHelpers()
{
	if(attackGroup.members == 0){
		return FALSE;
	}

	return TRUE;
}

function bool helpingAlly()
{
	if(lastHelpPlayer >= 0){
		return TRUE;
	}

	return FALSE;
}

/* Returns true if we were helping long enough */
function bool helpAllyTimeout()
{
	if(tHelpTimeout < (gameTime / 10) ){
		return TRUE;
	}

	return FALSE;
}

function bool canStopHelpingAlly()
{
	if(lastHelpPlayer < 0)
	{
		ASSERT(FALSE, "canStopHelpingAlly: lastHelpPlayer < 0", me);
		return TRUE;
	}

	/* Were helping long enough or someone's backstabbing */
	if(!friendlyPlayer(lastHelpPlayer)){
		return TRUE;
	}

	/* Nothing to defend anymore */
	//if(!allyBaseAtLoc(lastHelpPlayer, helpX, helpY)){
	//	return TRUE;
	//}

	return FALSE;
}

function void stopHelpingAlly()
{
	dbg("stopped helping", me);

	tHelp = -1;
	tHelpTimeout = -1;
	lastHelpPlayer = -1;
	helpX = -1;
	helpY = -1;

	stopDefendingLocation();
}

/* Send a multiplayer message to an ally */
function void messagePlayer(int _playerToMessage, string _message, int _probability)
{
	local int	_player;

	ASSERT(_playerToMessage >= -1 && _playerToMessage < MAX_PLAYERS,
		"messagePlayer: player out of bounds: " & _playerToMessage, me);

	// throw the dice
	if( random(MAX_PROBABILITY) >= _probability ){
		return;
	}

	_player = 0;
	if(_playerToMessage == ALL_ALLIES)	//everyone
	{
		while(_player < MAX_PLAYERS)
		{
			/* Send message (allies only)) */
			if(allianceExistsBetween(me, _player))
			{
				msg(_message, me, _player);
			}

			_player++;
		}
	}
	else	//a certain player
	{
		/* Send message (allies only)) */
		if(allianceExistsBetween(me, _playerToMessage))
		{
			msg(_message, me, _playerToMessage);
		}
	}
}

function int numBitsSet(int _integer)
{
	local	int		_position,_result;

	_position = 0;
	_result = 0;
	while(_position < 8)
	{
		if(getBit(_integer, _position))
		{
			_result++;
		}
		_position++;
	}

	return _result;
}

/* Send a multiplayer message, addressing some player(s) */
function void messagePlayerAddressed(int _playerToMessage, int _playersToAddress, string _message)
{
	local	int		_player,_totalAddressed,_curAddressed;
	local	string	_adrMessage;

	_totalAddressed = numBitsSet(_playersToAddress);

	ASSERT(_totalAddressed > 0, "messagePlayerAddressed: no players addressed", me);

	_adrMessage = " ";

	_player = 0;
	_curAddressed = 0;
	while(_player < MAX_PLAYERS)
	{
		if(getBit(_playersToAddress, _player))
		{
			_curAddressed++;

			_adrMessage = _adrMessage & getPlayerName(_player);

			//if(_totalAddressed == 1){	//one only
			//	_adrMessage = getPlayerName(_player);
			//}else

			if(_totalAddressed > 1)
			{
				if(_curAddressed == _totalAddressed){		//end
					_adrMessage = _adrMessage & " and " & getPlayerName(_player);
				}else{
					_adrMessage = _adrMessage & ", " & getPlayerName(_player);
				}
			}

		}
		_player++;
	}

	_message = _adrMessage &  " " & _message;

	//Now send the message to all players addressed
	messagePlayer(_playerToMessage, _message, MAX_PROBABILITY);
}

/* Returns true if we can see our allies on the map */
function bool canSeeAllies()
{
	local STRUCTURE _uplink;

	/* Can see allies when team mode is on */
	if(multiPlayerAlliancesType == ALLIANCES_TEAMS)
	{
		return TRUE;
	}

	/* Can see whole map if we have uplink */
	_uplink = getStructure(uplink, me);
	if(_uplink != NULLOBJECT)
	{
		/* Make sure finished building */
		if(structureComplete(_uplink))
		{
			return TRUE;
		}
	}

	return FALSE;
}

function bool defendingOwnBase()
{
	if(helpingAlly() && lastHelpPlayer == me){
		return TRUE;
	}

	return FALSE;
}

/* Call for help when our base is in danger */
event watchBaseThreat(watchBaseThreatTr)
{
	/* See if we can stop defending */
	if(defendingOwnBase())
	{
		if(numEnemiesInBase(FALSE) == 0)
		{
			stopHelpingAlly();	//stop defending our own base

			/* Let allies know we don't need their help anymore */
			messagePlayer(ALL_ALLIES, R_REPORT_SAFETY, MAX_PROBABILITY);
			exit;
		}
	}

	/* See if our base is in trouble and we need help */
	if(baseInTrouble())
	{
		if(!defendingOwnBase())	//make sure not already defending the base
		{
			if(_DEBUG)
				debug(me & ") watchBaseThreat: base in trouble");

			dbg("watchBaseThreat: base in trouble", me);

			/* Bring our forces back if needed */
			if(helpingAlly())
			{
				stopHelpingAlly();
			}

			/* Defend my own base */
			helpPlayer(me, baseX, baseY);
		}

		/* Request help once in a while */
		requestHelp(baseX, baseY);
		exit;
	}
}

function int numAlliesInBase(bool _bVtols)
{
	local int _numAllies;

	_numAllies = numFriendlyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
	_numAllies = _numAllies +
					numFriendlyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, true) / 3;

	return _numAllies;
}

function int numEnemiesInBase(bool _bVtols)
{
	local int _numEnemies;

	_numEnemies = numEnemyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, _bVtols);
	_numEnemies = _numEnemies +
				numEnemyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE, false) / 4;

	return _numEnemies;
}

/* Returns true if our base is in trouble */
function bool baseInTrouble()
{
	local int _enemyForce,_friendlyForce;

	_friendlyForce = numAlliesInBase(FALSE);
	_enemyForce = numEnemiesInBase(FALSE);

	/* See if we are in trouble */
	if((_enemyForce > 0) && (_enemyForce >= _friendlyForce)){
		dbg("baseInTrouble: " & _enemyForce & " >= " & _friendlyForce, me);
		return TRUE;
	}

	return FALSE;
}

/* Request help from allies */
function void requestHelp(int _helpX, int _helpY)
{
	/* Don't do this too frequently */
	if(tLastHelpRequest + HELP_REQUEST_INTERVAL > (gameTime / 10) ){
		return;
	}

	doRequestHelp(_helpX, _helpY);
}

function void doRequestHelp(int _helpX, int _helpY)
{
	local int _ally;

	/* Remember when we requested help last time */
	tLastHelpRequest = gameTime / 10;

	/* Drop beacon for all allies so they would know where to help */
	_ally = 0;
	while(_ally < MAX_PLAYERS)
	{
		if(allianceExistsBetween(me, _ally)){
			if(_DEBUG)
				debug(me & ") requestHelp: " & _ally);

			dropBeacon(getPlayerName(me), _ally, me, _helpX, _helpY, 0);
		}
		_ally++;
	}

	/* Now send message with help request */

}

function void defendLocation(int _defendX, int _defendY, int _tDefendTimeout, bool _bMove)
{
	local int defendRadius;

	defendRadius = 25 * TILE;

	dbg("starting defending for " & _tDefendTimeout - (gameTime / 10) & " secs, with defend radius " & defendRadius, me);

	defendX = _defendX;
	defendY = _defendY;

	tDefendStart = gameTime / 10;

	/* Should already include travel time */
	tDefendTimeout = _tDefendTimeout;

	/* See if we have to move or scout */
	defendMoveType = DORDER_SCOUT;
	if(_bMove){
		defendMoveType = DORDER_MOVE;
	}

	/* Send attackers */
	if(attackGroup.members > 0)
	{
		if(distBetweenTwoPoints(attackGroup.x, attackGroup.y, _defendX, _defendY) > defendRadius)
		{
			orderGroupLoc(attackGroup, defendMoveType, _defendX, _defendY);
		}
	}

	setEventTrigger(manageDefendLocationEv,	manageDefendLocationTr);
}

function void stopDefendingLocation()
{
	dbg("stopped defending location", me);

	defendX = -1;
	defendY = -1;

	tDefendStart = -1;
	tDefendTimeout = -1;

	defendMoveType = -1;

	setEventTrigger(manageDefendLocationEv,	inactive);

	orderGroupLoc(attackGroup, DORDER_SCOUT,baseX,baseY);
}

function bool defendingLocation()
{
	if(defendX > 0 and defendY > 0){
		return TRUE;
	}

	return FALSE;
}

event manageDefendLocationEv(inactive)
{
	local int defendRadius;
	local DROID _droid;

	if (not defendingLocation())
	{
		exit;
	}

	defendRadius = 15 * TILE;

	dbg("manageDefendLocationEv", me);

	ASSERT(defendMoveType == DORDER_MOVE || defendMoveType == DORDER_SCOUT,
		"manageDefendLocationEv: wrong move order:" & defendMoveType, me);

	ASSERT(defendX > 0 && defendY > 0,
		"manageDefendLocationEv: x/y coordinates:" & defendX & "/" & defendY, me);

	/* Collect attackers */
	initIterateGroup(attackGroup);
	_droid = iterateGroup(attackGroup);
	while(_droid != NULLOBJECT)
	{
		if(distBetweenTwoPoints(_droid.x,_droid.y,defendX,defendY) > defendRadius)	//too far from defend location
		{
			if(distBetweenTwoPoints(_droid.orderx,_droid.ordery,defendX,defendY) > defendRadius)	//not already on its way to the defend location
			{
				orderDroidLoc(_droid, defendMoveType, defendX, defendY);
			}
		}
		_droid = iterateGroup(attackGroup);
	}
}

function bool defendLocationTimeout()
{
	if(tDefendTimeout < (gameTime / 10) ){
		return TRUE;
	}

	return FALSE;
}

/* Returns true if player in question is my ally or if it's me */
function bool friendlyPlayer(int _playerToCheck)
{
	if(allianceExistsBetween(_playerToCheck, me) or (_playerToCheck == me)){
		return TRUE;
	}

	return FALSE;
}

function bool insideBase(int _x, int _y)
{
	if(_x < minx){
		return FALSE;
	}

	if(_x > maxx){
		return FALSE;
	}

	if(_y < miny){
		return FALSE;
	}

	if(_y > maxy){
		return FALSE;
	}

	return TRUE;
}

event watchMenu(everySec)
{
	if(_DEBUG)
	{
		
	/*
		setDebugMenuEntry("total " & countRebuildStruct, 0);
		setDebugMenuEntry("x1=" & rebuildStructX[0], 1);
		setDebugMenuEntry("y1=" & rebuildStructY[0], 2);
		setDebugMenuEntry("x2=" & rebuildStructX[1], 3);
		setDebugMenuEntry("y2=" & rebuildStructY[1], 4);
		setDebugMenuEntry("x3=" & rebuildStructX[2], 5);
		setDebugMenuEntry("y3=" & rebuildStructY[2], 6);
		setDebugMenuEntry("x4=" & rebuildStructX[3], 7);
		setDebugMenuEntry("y4=" & rebuildStructY[3], 8);*/
	}
}

//---------------------------------------------------------------
//Returns how many droids are already on the way to build the
//same structure on the same spot (like helpbuild)
//---------------------------------------------------------------
function int numBuildSameBuilding(STRUCTURESTAT _checkStat, int _x, int _y)
{
	local	int		_numSameBuilding;
	local	DROID	_truck;

	_numSameBuilding = 0;

	initIterateGroup(buildGroup);
	_truck = iterateGroup(buildGroup);
	while(_truck != NULLOBJECT)
	{
		if((_truck.order == DORDER_BUILD) or (_truck.order == DORDER_HELPBUILD) or (_truck.order == DORDER_LINEBUILD))
		{
			if((_checkStat == NULLSTRUCTURESTAT) or (_truck.stat == _checkStat))	//Same struct type
			{
				//Within some range
				if((_x < 0) or (distBetweenTwoPoints(_x, _y, _truck.orderx , _truck.ordery) <= TILE))
				{
					_numSameBuilding++;
				}
			}
		}
		_truck = iterateGroup(buildGroup);
	}

	return _numSameBuilding;
}

// returns number of droids in a certain group with the same order
function int numGroupSameOrder(GROUP _group, int _orderIndex)
{
	local		int 		_numDroids;
	local		DROID		_droid;

	_numDroids = 0;

	initIterateGroup(_group);
	_droid = iterateGroup(_group);
	while(_droid != NULLOBJECT)
	{
		if(_droid.order == _orderIndex)	//right order type
		{
			_numDroids++;
		}
		_droid = iterateGroup(_group);
	}

	return _numDroids;
}

// Remember certain destroyed structures so we can rebuild them later
event structureDestroyed(structureDestroyedTr)
{
	local	int	_count;
	local	 DROID _droid;

	// add certain structures to the rebuild list
	_count = 0;
	while(_count < numRebuildStat[curTech])
	{
		if(structure.stat == rebuildStat[curTech][_count])
		{
			if(countRebuildStruct < MAX_REBUILD_STRUCT)
			{
				rebuildStructX[countRebuildStruct] = structure.x;
				rebuildStructY[countRebuildStruct] = structure.y;
				rebuildStructStat[countRebuildStruct] = structure.stat;
				countRebuildStruct++;

				dbg("remembered structure (" & countRebuildStruct & ") - " & structure.x & "/" & structure.y, me);

				exit;
			}
		}
		_count++;
	}
	
	if((structure.stattype == REF_FACTORY) and (!friendlyPlayer(structure.player)) and (droidInRange(me, structure.x, structure.y, (5 * TILE))))
	{
		setEventTrigger(vtolAttack,	vtolAttackTr);
	}
}

// Rebuild structures that were destroyed
event rebuildStructureEv(rebuildStructureTr)
{
	rebuildStructures();
}

function void rebuildStructures()
{
	local	int				_count,_threatRange,_x,_y;
	local	DROID			_truck;
	local	STRUCTURESTAT	_stat;

	_threatRange = (TILE * 8);

	_count = 0;
	while(_count < countRebuildStruct)
	{
		if(!threatInRange(me, rebuildStructX[_count], rebuildStructY[_count], _threatRange, FALSE))
		{
			if(getTileStructure(_x / TILE, _y  / TILE) == NULLOBJECT)
			{
				_stat = rebuildStructStat[_count];
				_x = rebuildStructX[_count];
				_y = rebuildStructY[_count];

				if (isStructureAvailable(_stat, me))
				{
					_truck = closestIdleTruck(_x, _y);

					if (_truck != NULLOBJECT)
					{
						if (numBuildSameBuilding(_stat, _x, _y) == 0)	//make sure no one is building already
						{
							buildOnExactLocation(_truck, _x, _y, _stat);
						}
					}
				}
			}
		}
		_count++;
	}
}

function void buildOnExactLocation(DROID _truck, int _x, int _y, STRUCTURESTAT _stat)
{
	local	int	_newX,_newY;

	if(_truck == NULLOBJECT)
	{
		return;
	}

	_newX = _x;
	_newY = _y;

	if (pickDroidStructLocation(_truck, _stat, ref _newX, ref _newY, me, -1))
	{
		dbg("trying to rebuild on (" & _newX & "/" & _newY & ")", me);

		if ((_x != _newX) or (_y != _newY))
		{
			return;
		}

		orderDroidStatsLoc(_truck, DORDER_BUILD, _stat, _x, _y);
		//dbg("rebuilding structure after!! (" & _x & "/" & _y & ")", me);
	}
}

// Get idle truck closest to some location
function DROID closestIdleTruck(int _x, int _y)
{
	local DROID _closestTruck, _tempTruck;
	local int _closestDist, _tempDist;

	_closestTruck = NULLOBJECT;
	_closestDist = 99999;

	initIterateGroup(buildGroup);
	_tempTruck = iterateGroup(buildGroup);
	while(_tempTruck != NULLOBJECT)
	{
		if((_tempTruck.order == DORDER_NONE) or (_tempTruck.order == DORDER_RTB))
		{
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y);
			if(_tempDist < _closestDist)
			{
				_closestDist = _tempDist;
				_closestTruck = _tempTruck;
			}
		}
		_tempTruck = iterateGroup(buildGroup);
	}

	return _closestTruck;
}

event consoleEv(consoleTr)
{
	//turn on 'autogame'
	if(message == "autogame on" && (sender == me))
	{
		if(debugModeEnabled())
		{
			if(myResponsibility(me))
			{
				if(not bRunning)		//make sure current machine is responsible for this AI and it's not already active
				{
					console(getPlayerName(me) & " is active");
					reassignAI();
					setEventTrigger(startLevel, chainloadTr);
				}
			}
		}
	}

	//turn off 'autogames'
	if(message == "autogame off" && debugModeEnabled()  && (sender == me))
	{
		if(bRunning)		//make sure this AI is active
		{
			console(getPlayerName(me) & " is deactivated");
			
			shutDownAI();
		}
	}

	if(message == "aidebug on")
	{
		console(getPlayerName(me) & " ai debug is on");
		_DEBUG = TRUE;
		dbgMsgOn(me, _DEBUG);
	}
	else if(message == "aidebug off")
	{
		console(getPlayerName(me) & " ai debug is off");
		_DEBUG = FALSE;
		dbgMsgOn(me, _DEBUG);
	}
}
